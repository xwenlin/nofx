# 补丁日志 2025 (Patch Log 2025)

本文件记录2025年的所有自定义补丁和修复的详细信息。

---

## 2025-11-05 - 修复删除按钮双重确认和Aster DEX交易所状态显示问题

### 问题描述

#### 问题1：删除按钮双重确认对话框
- **问题**: 在编辑AI模型或交易所时，点击"删除"按钮会弹出两次确认对话框
- **原因**: 删除按钮的 `onClick` 事件中调用了 `confirm()`，而删除处理函数 `handleDeleteModelConfig`/`handleDeleteExchangeConfig` 中也调用了 `confirm()`
- **影响**: 用户体验不佳，需要确认两次才能删除

#### 问题2：Aster DEX交易所状态显示错误
- **问题**: Aster DEX交易所配置了所有必需字段（asterUser、asterSigner、asterPrivateKey）并保存后，前端状态指示器仍显示为灰色（未启用状态）
- **原因**: 前端状态判断逻辑只检查了 `exchange.enabled && exchange.apiKey`，但Aster交易所不使用 `apiKey` 字段，而是使用特殊的 `asterUser`、`asterSigner`、`asterPrivateKey` 字段
- **影响**: 用户无法通过状态指示器判断Aster交易所是否真正配置完成

### 修复方案

#### 1. 删除按钮双重确认修复
- 移除删除按钮 `onClick` 中的 `confirm()` 调用
- 保留删除处理函数中的 `confirm()`，确保只显示一次确认对话框
- 简化按钮的事件处理逻辑

#### 2. Aster DEX交易所状态显示修复
- 新增 `isExchangeFullyConfigured()` 辅助函数，根据不同的交易所类型判断配置是否完整
- 修复状态指示器（绿点/灰点）的判断逻辑
- 修复状态文本显示逻辑

### 修改文件

#### `web/src/components/AITradersPage.tsx`

##### 1. 删除按钮修复（第1043-1051行，第1276-1284行）

**修改前**:
```tsx
<button
  type="button"
  onClick={() => {
    if (confirm(t('confirmDeleteModel', language))) {
      onDelete(editingModelId);
    }
  }}
>
  <Trash2 className="w-4 h-4" />
</button>
```

**修改后**:
```tsx
<button
  type="button"
  onClick={() => onDelete(editingModelId)}
>
  <Trash2 className="w-4 h-4" />
</button>
```

##### 2. 新增交易所配置完整性检查函数（第146-165行）

```tsx
// 检查交易所是否配置完整且启用
const isExchangeFullyConfigured = (exchange: Exchange) => {
  if (!exchange.enabled) return false;

  // Aster 交易所需要特殊字段
  if (exchange.id === 'aster') {
    return exchange.asterUser && exchange.asterUser.trim() !== '' &&
      exchange.asterSigner && exchange.asterSigner.trim() !== '' &&
      exchange.asterPrivateKey && exchange.asterPrivateKey.trim() !== '';
  }

  // Hyperliquid 只需要私钥（作为apiKey）和钱包地址
  if (exchange.id === 'hyperliquid') {
    return exchange.apiKey && exchange.apiKey.trim() !== '' &&
      exchange.hyperliquidWalletAddr && exchange.hyperliquidWalletAddr.trim() !== '';
  }

  // Binance 等其他交易所需要 apiKey 和 secretKey
  return exchange.apiKey && exchange.apiKey.trim() !== '' && exchange.secretKey && exchange.secretKey.trim() !== '';
};
```

##### 3. 修复状态指示器显示（第710行）

**修改前**:
```tsx
<div className={`w-2.5 h-2.5 md:w-3 md:h-3 rounded-full flex-shrink-0 ${exchange.enabled && exchange.apiKey ? 'bg-green-400' : 'bg-gray-500'}`} />
```

**修改后**:
```tsx
<div className={`w-2.5 h-2.5 md:w-3 md:h-3 rounded-full flex-shrink-0 ${isExchangeFullyConfigured(exchange) ? 'bg-green-400' : 'bg-gray-500'}`} />
```

##### 4. 修复状态文本显示（第706行）

**修改前**:
```tsx
{exchange.type.toUpperCase()} • {inUse ? t('inUse', language) : exchange.enabled ? t('enabled', language) : t('configured', language)}
```

**修改后**:
```tsx
{exchange.type.toUpperCase()} • {inUse ? t('inUse', language) : isExchangeFullyConfigured(exchange) ? t('enabled', language) : t('configured', language)}
```

### 技术细节

#### 交易所类型判断逻辑

根据不同的交易所类型，使用不同的字段验证：

1. **Aster DEX** (`id === 'aster'`)
   - 必需字段：`asterUser`、`asterSigner`、`asterPrivateKey`
   - 所有字段必须非空

2. **Hyperliquid** (`id === 'hyperliquid'`)
   - 必需字段：`apiKey`（私钥）、`hyperliquidWalletAddr`（钱包地址）
   - 所有字段必须非空

3. **其他交易所**（Binance、OKX等）
   - 必需字段：`apiKey`、`secretKey`
   - 所有字段必须非空

#### 状态显示逻辑

- **绿色圆点** (`bg-green-400`): 交易所已启用且配置完整
- **灰色圆点** (`bg-gray-500`): 交易所未配置或配置不完整
- **状态文本**:
  - `inUse`: 正在被运行中的交易员使用
  - `enabled`: 已启用（配置完整）
  - `configured`: 已配置（但未启用或配置不完整）

### 修复效果

#### 删除功能
- ✅ 删除按钮现在只显示一次确认对话框
- ✅ 代码更简洁，逻辑更清晰
- ✅ 在Chrome和Firefox中都能正常工作

#### Aster DEX状态显示
- ✅ Aster DEX交易所配置完整后，状态指示器正确显示为绿色
- ✅ 状态文本正确显示为"已启用"
- ✅ 支持所有交易所类型的正确状态判断

### 兼容性说明

- **向后兼容**: 修改不影响现有功能，只是修复了状态显示逻辑
- **浏览器兼容**: 在Chrome和Firefox中测试通过
- **交易所类型**: 支持Aster、Hyperliquid、Binance、OKX等所有交易所类型

### 测试建议

1. **删除功能测试**:
   - 编辑AI模型，点击删除按钮，确认只弹出一次确认对话框
   - 编辑交易所，点击删除按钮，确认只弹出一次确认对话框

2. **状态显示测试**:
   - 配置Aster DEX交易所的所有必需字段，保存后检查状态指示器应为绿色
   - 配置Hyperliquid交易所，检查状态是否正确显示
   - 配置Binance交易所，检查状态是否正确显示

### 相关问题

- **Firefox兼容性问题**: 在调试过程中发现Firefox浏览器在某些情况下无法点击删除按钮，但最终确认为浏览器缓存问题，通过关闭标签页重新打开解决。代码本身没有兼容性问题。

---

## 2025-11-05 - 在决策列表中显示每个币种的决策原因

### 问题描述
- **需求**: 用户希望在决策列表中看到每个币种的决策原因（reasoning）
- **现状**: 前端只显示币种、操作类型、杠杆、价格等信息，但不显示AI的决策原因
- **影响**: 用户无法了解AI做出每个决策的具体原因，不利于理解和分析AI的交易逻辑

### 修复方案
1. **后端数据结构扩展**：
   - 在 `DecisionAction` 结构体中添加 `Reasoning` 字段
   - 在创建决策记录时保存AI返回的 `reasoning` 字段

2. **前端类型定义更新**：
   - 在 `DecisionAction` 接口中添加 `reasoning?: string` 字段
   - 确保TypeScript类型定义完整

3. **前端UI更新**：
   - 在决策卡片中显示决策原因
   - 使用分隔线和合适的样式，使原因信息清晰可见

### 修改文件

#### 1. `logger/decision_logger.go`
- **修改内容**:
  - 第52-62行：在 `DecisionAction` 结构体中添加 `Reasoning string` 字段
  - 字段说明：`json:"reasoning"` 用于存储AI提供的决策原因

#### 2. `trader/auto_trader.go`
- **修改内容**:
  - 第406-415行：在创建 `actionRecord` 时添加 `Reasoning: d.Reasoning`，保存AI的决策原因
  - 确保从AI决策中提取的 `reasoning` 字段被正确传递到记录中

#### 3. `web/src/types.ts`
- **修改内容**:
  - 第44-54行：在 `DecisionAction` 接口中添加 `reasoning?: string` 字段
  - 字段为可选，兼容旧数据（旧记录可能没有reasoning字段）

#### 4. `web/src/types/index.ts`
- **修改内容**:
  - 第43-53行：在 `DecisionAction` 接口中添加 `reasoning?: string` 字段
  - 保持与 `types.ts` 的一致性

#### 5. `web/src/App.tsx`
- **修改内容**:
  - 第764-793行：重构决策卡片显示逻辑
  - 将原来的单行显示改为多行结构：
    - 第一行：显示币种、操作类型、杠杆、价格、成功状态等信息
    - 第二行（如果有reasoning）：显示决策原因，使用分隔线和特殊样式
  - 第787-792行：添加reasoning显示逻辑，当 `action.reasoning` 存在时显示

### 技术细节

#### 数据结构
```go
// DecisionAction 决策动作
type DecisionAction struct {
    Action    string    `json:"action"`
    Symbol    string    `json:"symbol"`
    // ... 其他字段 ...
    Reasoning string    `json:"reasoning"` // 决策原因（AI提供的reasoning）
}
```

#### 前端显示逻辑
```typescript
{action.reasoning && (
  <div className="text-xs mt-1 pt-1" style={{ color: '#848E9C', borderTop: '1px solid #2B3139' }}>
    <span className="font-semibold" style={{ color: '#EAECEF' }}>原因：</span>
    <span>{action.reasoning}</span>
  </div>
)}
```

### UI效果

决策卡片现在显示为：
```
┌─────────────────────────────────────────┐
│ BTCUSDT [open_long] 10x @50000.00 ✓    │
│ ─────────────────────────────────────── │
│ 原因：MACD金叉+RSI超卖+成交量放大        │
└─────────────────────────────────────────┘
```

### 兼容性说明

- **向后兼容**: `reasoning` 字段为可选字段，旧记录如果没有reasoning字段不会导致错误
- **数据来源**: reasoning字段来自AI的决策JSON，AI在生成决策时会包含reasoning字段
- **显示条件**: 只有当reasoning字段存在且不为空时才显示，避免显示空白区域

### 修复效果

- ✅ 后端正确保存AI的决策原因
- ✅ 前端类型定义完整，支持reasoning字段
- ✅ 决策卡片清晰显示每个币种的决策原因
- ✅ UI样式统一，与其他信息区分明显
- ✅ 向后兼容，旧记录不会报错

### 测试建议

- [ ] 验证新决策记录是否包含reasoning字段
- [ ] 验证前端是否正确显示reasoning内容
- [ ] 验证没有reasoning的旧记录是否正常显示（不显示reasoning部分）
- [ ] 验证reasoning文本较长时的显示效果（换行、滚动等）
- [ ] 验证多个决策卡片的reasoning显示是否一致

---

## 2025-11-05 - 修复前端路径配置问题（合并dev分支后）

### 问题描述
- **BUG**: 合并新的dev分支后，前端访问的路径都没有前缀了
- **影响**: 前端无法正确访问静态资源、API接口和路由页面
- **根本原因**: dev分支覆盖了之前配置的 `/nofx/` base路径和 `/nofx-api` API前缀

### 修复方案
1. **API路径修复**：
   - 修复 `AuthContext.tsx` 中注册接口的路径
   - 确保所有API调用使用 `/nofx-api` 前缀

2. **路由适配base路径**：
   - 创建工具函数处理路由路径（`getBasePath`, `getFullPath`, `removeBasePath`）
   - 所有路由匹配和导航都适配base路径

3. **静态资源路径修复**：
   - 创建工具函数处理静态资源路径（`getIconPath`, `getImagePath`, `getLinkPath`）
   - 所有组件中的静态资源路径都使用工具函数

4. **页面跳转修复**：
   - 所有页面跳转都使用适配base路径的工具函数

### 修改文件

#### 1. `web/src/lib/api.ts`
- **状态**: ✅ 已正确配置
- **内容**: `API_BASE = '/nofx-api'` 已正确设置

#### 2. `web/src/lib/config.ts`
- **状态**: ✅ 已正确配置
- **内容**: 使用 `/nofx-api/config` 已正确设置

#### 3. `web/src/contexts/AuthContext.tsx`
- **修改内容**:
  - 第99行：注册接口从 `/api/register` 改为 `/nofx-api/register`
  - 第146、179行：登录/注册成功后的首页跳转使用 `import.meta.env.BASE_URL`

#### 4. `web/src/App.tsx`
- **修改内容**:
  - 第28-46行：添加工具函数 `getBasePath()`, `getFullPath()`, `removeBasePath()`
  - 第69-77行：`getInitialPage()` 函数使用 `removeBasePath()` 处理路径
  - 第83-98行：路由变化监听使用 `removeBasePath()` 处理路径
  - 第210-219行：路由状态同步使用 `removeBasePath()` 处理路径
  - 第234-241行：路由匹配使用 `removeBasePath()` 处理路径
  - 第256-274行：页面导航使用 `getFullPath()` 生成完整路径
  - 第310-325行：主应用导航使用 `getFullPath()` 生成完整路径
  - 第335-341行：交易员选择导航使用 `getFullPath()` 生成完整路径

#### 5. `web/src/pages/LandingPage.tsx`
- **修改内容**:
  - 第36-43行：页面跳转使用 `import.meta.env.BASE_URL` 适配base路径

#### 6. `web/src/components/LoginPage.tsx`
- **修改内容**:
  - 第64-67行：页面跳转使用 `import.meta.env.BASE_URL` 适配base路径

#### 7. `web/src/components/RegisterPage.tsx`
- **修改内容**:
  - 第102-105行：页面跳转使用 `import.meta.env.BASE_URL` 适配base路径

#### 8. `web/src/components/ModelIcons.tsx`
- **修改内容**:
  - 第17-25行：新增 `getLinkPath()` 函数，用于生成适配base路径的链接

#### 9. `web/src/components/landing/HeroSection.tsx`
- **修改内容**:
  - 第4行：导入 `getImagePath` 函数
  - 第111行：图片路径从 `/images/hand-bg.png` 改为 `getImagePath('hand-bg.png')`
  - 第121行：图片路径从 `/images/hand.png` 改为 `getImagePath('hand.png')`

#### 10. `web/src/components/landing/HeaderBar.tsx`
- **修改内容**:
  - 第5行：导入 `getLinkPath` 和 `getIconPath` 函数
  - 第49行：Logo链接从 `href='/'` 改为 `href={getLinkPath('/')}`
  - 第180行：竞赛页面链接从 `href='/competition'` 改为 `href={getLinkPath('/competition')}`
  - 第292行：登录页面链接从 `href='/login'` 改为 `href={getLinkPath('/login')}`
  - 第299行：注册页面链接从 `href='/register'` 改为 `href={getLinkPath('/register')}`
  - 第416行：移动端竞赛页面链接从 `href='/competition'` 改为 `href={getLinkPath('/competition')}`
  - 第590行：移动端登录页面链接从 `href='/login'` 改为 `href={getLinkPath('/login')}`
  - 第598行：移动端注册页面链接从 `href='/register'` 改为 `href={getLinkPath('/register')}`

#### 11. `web/index.html`
- **修改内容**:
  - 第16行：Favicon路径保持为 `/icons/nofx.svg`（Vite构建时会自动处理base路径）

### 技术细节

#### 工具函数说明

**`getBasePath()`**:
```typescript
const getBasePath = () => import.meta.env.BASE_URL || '/';
```
- 获取base路径（通常是 `/nofx/`）

**`getFullPath(path: string)`**:
```typescript
const getFullPath = (path: string) => {
  const base = getBasePath();
  if (base === '/') return path;
  if (path === '/' || path === '') return base.slice(0, -1);
  return base.slice(0, -1) + path;
};
```
- 将相对路径转换为完整的base路径
- 例如：`getFullPath('/competition')` → `/nofx/competition`

**`removeBasePath(fullPath: string)`**:
```typescript
const removeBasePath = (fullPath: string): string => {
  const base = getBasePath();
  if (base === '/' || !fullPath.startsWith(base)) return fullPath;
  const relative = fullPath.slice(base.length - 1);
  return relative || '/';
};
```
- 从完整路径中移除base路径，获取相对路径
- 例如：`removeBasePath('/nofx/competition')` → `/competition`

**`getLinkPath(path: string)`** (在 `ModelIcons.tsx` 中):
```typescript
export const getLinkPath = (path: string): string => {
  const baseUrl = import.meta.env.BASE_URL || '/';
  if (baseUrl === '/') return path;
  const baseWithoutSlash = baseUrl.slice(0, -1);
  return `${baseWithoutSlash}${path}`;
};
```
- 生成适配base路径的链接路径
- 例如：`getLinkPath('/competition')` → `/nofx/competition`

### 配置确认

#### `web/vite.config.ts`
```typescript
export default defineConfig({
  plugins: [react()],
  base: '/nofx/',  // ✅ 已正确配置
  server: {
    host: '0.0.0.0',
    port: 3000,
    proxy: {
      '/nofx-api': {  // ✅ 已正确配置
        target: 'http://localhost:18080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/nofx-api/, '/api'),
      },
    },
  },
})
```

#### `nginx/nginx.conf`
```nginx
location /nofx-api/ {
    proxy_pass http://nofx:8080/api/;
    # ...
}
```
- ✅ nginx配置已正确

### 修复效果

- ✅ 所有API调用使用 `/nofx-api` 前缀
- ✅ 所有路由匹配和导航适配 `/nofx/` base路径
- ✅ 所有静态资源路径适配base路径
- ✅ 所有页面跳转适配base路径
- ✅ 前端可以正确部署在 `/nofx/` 子路径下

### 测试建议

- [ ] 验证所有API调用是否正确使用 `/nofx-api` 前缀
- [ ] 验证所有路由页面是否可以通过 `/nofx/` 前缀访问
- [ ] 验证静态资源（图片、图标）是否正常加载
- [ ] 验证页面跳转是否正常工作
- [ ] 验证favicon是否正常显示

---

## 2025-11-05 - 补充WebSocket订阅缺失的周期数据（15m和1h）

### 问题描述
- **BUG**: WebSocket订阅只包含了3m和4h的数据，缺少15m和1h周期的实时数据订阅
- **影响**: 系统需要4个周期的数据（3m、15m、1h、4h），但只有3m和4h通过WebSocket实时更新，15m和1h只能通过HTTP API获取，无法实时更新
- **根本原因**: `subKlineTime` 数组只定义了 `["3m", "4h"]`，缺少 `"15m"` 和 `"1h"`

### 修复方案
1. **更新 `subKlineTime` 数组**：
   - 添加 `"15m"` 和 `"1h"` 到订阅周期列表
   - 现在订阅所有4个周期：`["3m", "15m", "1h", "4h"]`

2. **扩展 `WSMonitor` 结构体**：
   - 添加 `klineDataMap15m sync.Map` 用于存储15分钟K线数据
   - 添加 `klineDataMap1h sync.Map` 用于存储1小时K线数据

3. **更新历史数据初始化**：
   - `initializeHistoricalData()` 函数现在会加载所有4个周期的历史数据
   - 每个周期独立加载，错误不影响其他周期

4. **更新数据映射函数**：
   - `getKlineDataMap()` 函数使用 `switch` 语句支持所有4个周期
   - 支持 `"3m"`, `"15m"`, `"1h"`, `"4h"` 周期

### 代码变更
- `market/monitor.go`:
  - 第18-21行：添加 `klineDataMap15m` 和 `klineDataMap1h` 字段
  - 第39行：更新 `subKlineTime` 数组，添加 `"15m"` 和 `"1h"`
  - 第93-131行：更新 `initializeHistoricalData()`，加载所有4个周期的历史数据
  - 第239-255行：更新 `getKlineDataMap()`，使用 `switch` 支持所有周期

### 技术细节
- **WebSocket订阅**: 现在会为所有交易对订阅4个周期的K线数据
- **数据存储**: 每个周期使用独立的 `sync.Map` 存储，避免数据混淆
- **向后兼容**: 对于未知周期，返回临时的 `sync.Map`，不影响HTTP API获取

### 测试建议
- [ ] 验证WebSocket连接后，所有4个周期的数据都能实时更新
- [ ] 验证15m和1h的数据不再需要通过HTTP API获取（首次获取后通过WebSocket实时更新）
- [ ] 验证系统性能，确保订阅4个周期不会导致连接数过多或性能下降

---

## 2025-11-05 - 修复更新止损止盈时订单未删除的BUG

### 问题描述
- **BUG**: `update_stop_loss` 和 `update_take_profit` 功能在更新止损止盈时，旧订单没有被删除，导致订单累积
- **场景**: 用户看到多个止损/止盈订单同时存在（如截图所示有4个订单）
- **根本原因**: 
  - 币安Futures采用双向持仓模式(Hedge Mode)，每个symbol可以同时持有LONG和SHORT两个方向的仓位
  - 创建订单时指定了 PositionSide（LONG/SHORT）
  - 取消订单时未遍历所有订单，导致部分订单残留

### 修复方案
1. **修改 `CancelAllOrders` 接口**：
   - 添加可选的 `positionSide` 参数（变长参数，向后兼容）
   - 如果指定了 `positionSide`，先获取订单列表，然后只取消匹配 `PositionSide` 的订单
   - 如果没有指定，使用原有的 `CancelAllOpenOrders` API 取消所有订单

2. **实现细节**：
   - `trader/binance_futures.go`: 实现按 `PositionSide` 过滤订单的逻辑
   - `trader/aster_trader.go`: 支持 `positionSide` 参数（Aster API 原生支持）
   - `trader/hyperliquid_trader.go`: 支持 `positionSide` 参数（Hyperliquid 不支持 PositionSide，忽略该参数但保留日志）
   - `trader/auto_trader.go`: 在 `executeUpdateStopLossWithRecord` 和 `executeUpdateTakeProfitWithRecord` 中传入 `PositionSide`

3. **代码变更**：
   - `trader/interface.go`: `CancelAllOrders(symbol string, positionSide ...string) error`
   - `trader/binance_futures.go`: 实现按 `PositionSide` 过滤订单的逻辑
   - `trader/aster_trader.go`: 支持 `positionSide` 参数
   - `trader/hyperliquid_trader.go`: 支持 `positionSide` 参数（忽略）
   - `trader/auto_trader.go`: 更新止损/止盈时传入 `PositionSide`

### 技术细节
- **币安API**: `CancelAllOpenOrdersService` 不直接支持 `PositionSide` 参数
- **解决方案**: 使用 `ListOpenOrdersService` 获取订单列表，然后使用 `CancelOrderService` 逐个取消匹配的订单
- **向后兼容**: 如果不传入 `positionSide`，行为与之前完全一致（取消所有订单）

### 测试建议
- [ ] 测试更新 LONG 方向的止损，确保只取消 LONG 方向的订单
- [ ] 测试更新 SHORT 方向的止损，确保只取消 SHORT 方向的订单
- [ ] 测试双向持仓场景，确保更新一个方向的止损不影响另一个方向的订单
- [ ] 测试不传入 `positionSide` 的场景，确保向后兼容

---

## 2025-11-05 - 实现部分平仓、更新止损、更新止盈功能

### 问题描述
提示词模板中定义了以下动态调整操作，但代码层面未实现：
1. **部分平仓** (`partial_close`)：分批止盈，降低风险
2. **更新止损** (`update_stop_loss`)：持仓盈利后追踪止损，锁定利润
3. **更新止盈** (`update_take_profit`)：优化目标位，适应技术位变化

这些功能在交易策略中非常重要，可以帮助AI更好地管理持仓，提高收益和风险控制能力。

### 根本原因
1. **代码层面缺少实现**：
   - 虽然有 `SetStopLoss` 和 `SetTakeProfit` 接口，但只在开仓时设置
   - 没有更新止损止盈的功能
   - 虽然有 `CloseLong` 和 `CloseShort` 接口支持部分平仓，但没有封装成独立的action

2. **数据结构不完整**：
   - `Decision` 结构体缺少 `ClosePercentage`、`NewStopLoss`、`NewTakeProfit` 字段

3. **验证逻辑不完整**：
   - 验证函数中没有对新action的验证逻辑

### 修改文件
- `decision/engine.go` - 扩展数据结构，更新验证逻辑和输出格式
- `trader/auto_trader.go` - 实现三个新功能的执行逻辑
- `prompts/fusion_adaptive_taro_compact.txt` - 更新动作说明
- `prompts/fusion_adaptive_taro.txt` - 更新动作说明和使用示例
- `prompts/adaptive.txt` - 更新动作说明

### 具体修改

#### 1. 扩展 `Decision` 结构体（`decision/engine.go` 第71-87行）

**修改前：**
```go
type Decision struct {
    Symbol          string  `json:"symbol"`
    Action          string  `json:"action"` // "open_long", "open_short", "close_long", "close_short", "hold", "wait"
    Leverage        int     `json:"leverage,omitempty"`
    PositionSizeUSD float64 `json:"position_size_usd,omitempty"`
    StopLoss        float64 `json:"stop_loss,omitempty"`
    TakeProfit      float64 `json:"take_profit,omitempty"`
    Confidence      int     `json:"confidence,omitempty"`
    RiskUSD         float64 `json:"risk_usd,omitempty"`
    Reasoning       string  `json:"reasoning"`
}
```

**修改后：**
```go
type Decision struct {
    Symbol          string  `json:"symbol"`
    Action          string  `json:"action"` // "open_long", "open_short", "close_long", "close_short", "hold", "wait", "partial_close", "update_stop_loss", "update_take_profit"
    Leverage        int     `json:"leverage,omitempty"`
    PositionSizeUSD float64 `json:"position_size_usd,omitempty"`
    StopLoss        float64 `json:"stop_loss,omitempty"`
    TakeProfit      float64 `json:"take_profit,omitempty"`
    Confidence      int     `json:"confidence,omitempty"`
    RiskUSD         float64 `json:"risk_usd,omitempty"`
    Reasoning       string  `json:"reasoning"`
    // 部分平仓相关字段
    ClosePercentage float64 `json:"close_percentage,omitempty"` // 部分平仓百分比 (0-100)
    // 更新止损止盈相关字段
    NewStopLoss   float64 `json:"new_stop_loss,omitempty"`   // 新的止损价格
    NewTakeProfit float64 `json:"new_take_profit,omitempty"` // 新的止盈价格
}
```

#### 2. 更新验证逻辑（`decision/engine.go` 第560-683行）

**新增验证：**
```go
// 验证action
validActions := map[string]bool{
    "open_long":        true,
    "open_short":       true,
    "close_long":       true,
    "close_short":      true,
    "hold":             true,
    "wait":             true,
    "partial_close":    true,      // 新增
    "update_stop_loss": true,      // 新增
    "update_take_profit": true,   // 新增
}

// 部分平仓操作验证
if d.Action == "partial_close" {
    if d.ClosePercentage <= 0 || d.ClosePercentage > 100 {
        return fmt.Errorf("平仓百分比必须在 0-100 之间: %.2f", d.ClosePercentage)
    }
    if d.Symbol == "" {
        return fmt.Errorf("部分平仓必须指定币种")
    }
}

// 更新止损操作验证
if d.Action == "update_stop_loss" {
    if d.NewStopLoss <= 0 {
        return fmt.Errorf("新止损价格必须大于0: %.2f", d.NewStopLoss)
    }
    if d.Symbol == "" {
        return fmt.Errorf("更新止损必须指定币种")
    }
}

// 更新止盈操作验证
if d.Action == "update_take_profit" {
    if d.NewTakeProfit <= 0 {
        return fmt.Errorf("新止盈价格必须大于0: %.2f", d.NewTakeProfit)
    }
    if d.Symbol == "" {
        return fmt.Errorf("更新止盈必须指定币种")
    }
}
```

#### 3. 更新输出格式说明（`decision/engine.go` 第285-291行）

**修改前：**
```go
sb.WriteString("- `action`: open_long | open_short | close_long | close_short | hold | wait\n")
sb.WriteString("- 开仓时必填: leverage, position_size_usd, stop_loss, take_profit, confidence, risk_usd, reasoning\n\n")
```

**修改后：**
```go
sb.WriteString("- `action`: open_long | open_short | close_long | close_short | hold | wait | partial_close | update_stop_loss | update_take_profit\n")
sb.WriteString("- 开仓时必填: leverage, position_size_usd, stop_loss, take_profit, confidence, risk_usd, reasoning\n")
sb.WriteString("- 部分平仓时必填: close_percentage (0-100), stop_loss, take_profit (为剩余仓位重新设置)\n")
sb.WriteString("- 更新止损时必填: new_stop_loss\n")
sb.WriteString("- 更新止盈时必填: new_take_profit\n\n")
```

#### 4. 实现部分平仓功能（`trader/auto_trader.go` 第782-864行）

**新增函数：**
```go
func (at *AutoTrader) executePartialCloseWithRecord(decision *decision.Decision, actionRecord *logger.DecisionAction) error {
    // 1. 验证平仓百分比 (0-100)
    // 2. 获取当前持仓信息（symbol, side, quantity）
    // 3. 计算要平仓的数量 = quantity × (close_percentage / 100.0)
    // 4. 执行部分平仓（调用 CloseLong 或 CloseShort）
    // 5. 取消旧的止损止盈订单
    // 6. 为剩余仓位重新设置止损止盈（如果决策中提供了）
}
```

**关键特性：**
- ✅ 自动计算平仓数量
- ✅ 支持多仓和空仓
- ✅ 自动为剩余仓位重新设置止损止盈
- ✅ 详细的日志记录

#### 5. 实现更新止损功能（`trader/auto_trader.go` 第866-957行）

**新增函数：**
```go
func (at *AutoTrader) executeUpdateStopLossWithRecord(decision *decision.Decision, actionRecord *logger.DecisionAction) error {
    // 1. 验证新止损价格
    // 2. 获取当前持仓信息（symbol, side, quantity）
    // 3. 获取当前价格
    // 4. 安全验证：多仓止损只能上移，空仓止损只能下移
    // 5. 取消旧的止损订单（重试3次）
    // 6. 创建新的止损订单
}
```

**关键特性：**
- ✅ **安全验证**：多仓止损只能上移，空仓止损只能下移（防止错误操作）
- ✅ **重试机制**：订单取消失败时重试3次
- ✅ **详细日志**：记录旧止损和新止损价格

#### 6. 实现更新止盈功能（`trader/auto_trader.go` 第959-1044行）

**新增函数：**
```go
func (at *AutoTrader) executeUpdateTakeProfitWithRecord(decision *decision.Decision, actionRecord *logger.DecisionAction) error {
    // 1. 验证新止盈价格
    // 2. 获取当前持仓信息（symbol, side, quantity）
    // 3. 获取当前价格
    // 4. 价格合理性警告（非强制）
    // 5. 取消旧的止盈订单（重试3次）
    // 6. 创建新的止盈订单
}
```

**关键特性：**
- ✅ **灵活调整**：止盈价格可以任意调整（既可以提前止盈，也可以追高）
- ✅ **重试机制**：订单取消失败时重试3次
- ✅ **价格警告**：如果止盈价格不合理，会发出警告（但不阻止操作）

#### 7. 更新执行逻辑（`trader/auto_trader.go` 第586-608行）

**修改前：**
```go
switch decision.Action {
case "open_long":
    return at.executeOpenLongWithRecord(decision, actionRecord)
case "open_short":
    return at.executeOpenShortWithRecord(decision, actionRecord)
case "close_long":
    return at.executeCloseLongWithRecord(decision, actionRecord)
case "close_short":
    return at.executeCloseShortWithRecord(decision, actionRecord)
case "hold", "wait":
    return nil
default:
    return fmt.Errorf("未知的action: %s", decision.Action)
}
```

**修改后：**
```go
switch decision.Action {
case "open_long":
    return at.executeOpenLongWithRecord(decision, actionRecord)
case "open_short":
    return at.executeOpenShortWithRecord(decision, actionRecord)
case "close_long":
    return at.executeCloseLongWithRecord(decision, actionRecord)
case "close_short":
    return at.executeCloseShortWithRecord(decision, actionRecord)
case "partial_close":
    return at.executePartialCloseWithRecord(decision, actionRecord)  // 新增
case "update_stop_loss":
    return at.executeUpdateStopLossWithRecord(decision, actionRecord)  // 新增
case "update_take_profit":
    return at.executeUpdateTakeProfitWithRecord(decision, actionRecord)  // 新增
case "hold", "wait":
    return nil
default:
    return fmt.Errorf("未知的action: %s", decision.Action)
}
```

#### 8. 添加依赖导入（`trader/auto_trader.go` 第3-15行）

**新增导入：**
```go
import (
    // ... 其他导入
    "strconv"  // 新增：用于解析字符串数量
)
```

#### 9. 更新提示词模板

**`fusion_adaptive_taro_compact.txt`：**
- 添加三个新action的说明
- 更新持仓管理流程，说明何时使用这些操作

**`fusion_adaptive_taro.txt`：**
- 添加详细的action说明（参数、使用时机、限制）
- 更新动态调整策略部分，提供详细的使用示例

**`adaptive.txt`：**
- 添加三个新action的说明

### 修改说明

#### 1. 部分平仓 (`partial_close`)

**功能**：
- 按百分比平仓（0-100%）
- 自动为剩余仓位重新设置止损止盈
- 降低风险，锁定部分利润

**使用场景**：
- 盈利达到第一目标（5-10%）时，平仓50-70%
- 市场不确定性增加时，先平仓部分仓位
- 盈利达到预期的2/3时，平仓1/2，让剩余仓位追求更大目标

**示例JSON**：
```json
{
  "symbol": "BTCUSDT",
  "action": "partial_close",
  "close_percentage": 50,
  "stop_loss": 105000,
  "take_profit": 120000,
  "reasoning": "盈利10%，部分平仓锁定利润"
}
```

#### 2. 更新止损 (`update_stop_loss`)

**功能**：
- 更新持仓的止损价格
- 安全验证：只能往有利方向调整（多仓止损上移，空仓止损下移）
- 重试机制：订单取消失败时重试3次

**使用场景**：
- 持仓盈利3-5%时，将止损移至成本价（保本）
- 持仓盈利10%时，将止损移至入场价+5%（锁定部分利润）
- 价格持续上涨，每上涨5%，止损上移3%

**安全限制**：
- 多仓止损只能上移（不能下移）
- 空仓止损只能下移（不能上移）
- 防止AI错误地将止损调整到不利方向

**示例JSON**：
```json
{
  "symbol": "ETHUSDT",
  "action": "update_stop_loss",
  "new_stop_loss": 3600,
  "reasoning": "盈利5%，将止损移至成本价"
}
```

#### 3. 更新止盈 (`update_take_profit`)

**功能**：
- 更新持仓的止盈价格
- 可以任意调整（既可以提前止盈，也可以追高）
- 重试机制：订单取消失败时重试3次

**使用场景**：
- 价格接近目标但遇到强阻力 → 提前降低止盈价格
- 价格突破预期阻力位 → 追高止盈价格
- 技术位发生变化（支撑/阻力位突破）

**示例JSON**：
```json
{
  "symbol": "SOLUSDT",
  "action": "update_take_profit",
  "new_take_profit": 250,
  "reasoning": "突破阻力位，追高止盈目标"
}
```

### 风险控制措施

1. **止损验证**：
   - 多仓止损只能上移（更有利方向）
   - 空仓止损只能下移（更有利方向）
   - 防止错误地将止损调整到不利方向

2. **重试机制**：
   - 订单取消失败时重试3次
   - 每次重试间隔1秒
   - 即使重试失败，也会继续创建新订单（避免错过保护）

3. **参数验证**：
   - 部分平仓百分比必须在0-100之间
   - 新止损价格必须大于0
   - 新止盈价格必须大于0
   - 所有操作都必须指定币种

4. **日志记录**：
   - 详细的操作日志（当前持仓、平仓数量、新价格等）
   - 便于追踪和调试

### 影响范围

- ✅ **功能完整性**：AI现在可以使用完整的动态调整策略
- ✅ **风险控制**：更好的持仓管理和风险控制能力
- ✅ **收益优化**：部分平仓和追踪止损可以提高收益
- ✅ **灵活性**：止盈价格可以灵活调整，适应市场变化

### 测试建议

1. **部分平仓测试**：
   - 验证平仓百分比计算正确
   - 验证剩余仓位是否正确设置止损止盈
   - 验证平仓数量精度处理正确

2. **更新止损测试**：
   - 验证多仓止损只能上移（不能下移）
   - 验证空仓止损只能下移（不能上移）
   - 验证订单取消和创建的重试机制

3. **更新止盈测试**：
   - 验证止盈价格可以任意调整
   - 验证订单取消和创建的重试机制
   - 验证价格合理性警告

4. **错误处理测试**：
   - 测试无效百分比（<0 或 >100）
   - 测试无效价格（<=0）
   - 测试未找到持仓的情况

---

## 2025-11-05 - 优化用户提示词结构（避免重复+清晰分离）

### 问题描述
用户提示词结构存在以下问题：
1. **数据重复**：如果某个币种既是持仓币种，又在候选币种列表中，其市场数据会被重复输出
2. **结构不清晰**：账户信息、持仓信息、市场数据混杂在一起，逻辑不够清晰
3. **BTC特殊地位不突出**：BTC作为市场领导者，应该单独强调，但当前实现中位置不够突出
4. **数据顺序说明不明显**：提示词要求"OLDEST → NEWEST"的顺序，但说明不够醒目

### 根本原因
1. **输出顺序不当**：
   - 当前实现：时间 → 账户 → 持仓 → BTC → 候选币种 → 历史表现
   - 更好的顺序：时间 → 账户 → 持仓（含市场数据）→ 历史表现 → BTC → 候选币种

2. **标题层级不清晰**：
   - 缺少明确的section分隔（账户信息、市场状态）
   - BTC的特殊地位没有单独强调

3. **数据顺序说明缺失**：
   - 提示词中虽然有说明，但不够醒目
   - 应该在开头明确说明所有数据都是 OLDEST → NEWEST

### 修改文件
- `decision/engine.go` - 重构 `buildUserPrompt` 函数

### 具体修改

#### 修改后的结构

**新的提示词结构：**
```
时间: 2025-11-02 13:29:10 | 周期: #8 | 运行: 21分钟

**ALL OF THE PRICE OR SIGNAL DATA BELOW IS ORDERED: OLDEST → NEWEST**

# HERE IS YOUR ACCOUNT INFORMATION & PERFORMANCE

账户: 净值378.61 | 余额290.45 (76.7%) | 盈亏-5.35% | 保证金22.8% | 持仓1个

## 当前持仓：

1. HYPEUSDT SHORT | 入场价39.5730 当前价39.3370 | 盈亏+0.60% | 杠杆5x | 保证金65 | 强平价47.0252 | 持仓时长8分钟
[完整市场数据 - 3m/15m/1h/4h序列、技术指标等]

2. ETHUSDT SHORT | 入场价3592.8000 当前价3569.5278 | 盈亏+0.65% | 杠杆5x | 保证金124 | 强平价4294.2136 | 持仓时长3小时47分钟
[完整市场数据 - 3m/15m/1h/4h序列、技术指标等]

## 历史表现分析：

**夏普比率**: 0.04  (这是你的核心绩效指标，用于调整交易策略)
**总交易数**: 22 (最近1000个周期内，用于判断交易频率是否合理)

---

# CURRENT MARKET STATE FOR ALL COINS

## BTC市场状态（市场领导者，交易前必须确认BTC状态）

[完整市场数据 - 仅当BTC不是持仓币种时显示]

## 候选币种：

### 1. ETHUSDT (AI500+OI_Top双重信号)
[完整市场数据 - 仅当ETHUSDT不是持仓币种时显示]

### 2. SOLUSDT (OI_Top持仓增长)
[完整市场数据]

---

现在请分析并输出决策（思维链 + JSON）
```

#### 代码修改要点

1. **添加数据顺序说明**：
```go
// 2. 数据顺序说明
sb.WriteString("**ALL OF THE PRICE OR SIGNAL DATA BELOW IS ORDERED: OLDEST → NEWEST**\n\n")
```

2. **账户信息前置并添加标题**：
```go
// 3. 账户信息和表现（前置）
sb.WriteString("# HERE IS YOUR ACCOUNT INFORMATION & PERFORMANCE\n\n")
sb.WriteString(fmt.Sprintf("账户: 净值%.2f | ...\n\n", ...))
```

3. **当前持仓包含完整市场数据**：
```go
// 4. 当前持仓（包含完整市场数据）
if len(ctx.Positions) > 0 {
    sb.WriteString("## 当前持仓：\n\n")
    for i, pos := range ctx.Positions {
        // 持仓信息
        sb.WriteString(fmt.Sprintf("%d. %s %s | ...\n\n", ...))
        
        // 输出完整市场数据（便于AI分析是否需要平仓）
        if marketData, ok := ctx.MarketDataMap[pos.Symbol]; ok {
            sb.WriteString(market.Format(marketData))
            sb.WriteString("\n")
            displayedSymbols[pos.Symbol] = true // 标记已输出
        }
    }
}
```

4. **历史表现分析前置**：
```go
// 5. 历史表现分析
if ctx.Performance != nil {
    sb.WriteString("## 历史表现分析：\n\n")
    // ...
}
```

5. **BTC单独强调**：
```go
// 7. BTC市场状态（单独强调，仅当BTC不是持仓币种时）
if btcData, hasBTCData := ctx.MarketDataMap["BTCUSDT"]; hasBTCData && !displayedSymbols["BTCUSDT"] {
    sb.WriteString("# CURRENT MARKET STATE FOR ALL COINS\n\n")
    sb.WriteString("## BTC市场状态（市场领导者，交易前必须确认BTC状态）\n\n")
    sb.WriteString(market.Format(btcData))
    sb.WriteString("\n")
    displayedSymbols["BTCUSDT"] = true
}
```

6. **候选币种排除已输出币种**：
```go
// 8. 候选币种（完整市场数据）- 排除已输出的持仓币种
if hasCandidates {
    sb.WriteString("## 候选币种：\n\n")
    for _, coin := range ctx.CandidateCoins {
        // 跳过已输出的币种（持仓币种）
        if displayedSymbols[coin.Symbol] {
            continue
        }
        // ...
    }
}
```

### 修改说明

1. **结构清晰分离**：
   - 账户信息和表现部分（前置）
   - 市场状态部分（后置）
   - 使用 `---` 分隔符明确区分

2. **避免数据重复**：
   - 使用 `displayedSymbols` map 记录已输出的币种
   - 持仓币种的市场数据在"当前持仓"部分显示
   - 候选币种的市场数据在"候选币种"部分显示（排除已输出的持仓币种）
   - BTC如果不是持仓币种，单独显示

3. **BTC特殊地位突出**：
   - BTC单独一个section，标题明确其特殊地位："市场领导者，交易前必须确认BTC状态"
   - 符合提示词要求（"BTC优先"原则）

4. **数据顺序说明醒目**：
   - 在开头明确说明所有数据都是 OLDEST → NEWEST
   - 使用粗体标记，更加醒目

5. **持仓币种包含完整市场数据**：
   - 每个持仓币种下面都显示完整市场数据
   - 便于AI分析是否需要平仓、调整止损止盈

### 影响范围

- ✅ **结构更清晰**：账户信息、持仓信息、市场数据明确分离
- ✅ **避免重复**：每个币种的市场数据只输出一次
- ✅ **BTC特殊地位突出**：符合提示词要求
- ✅ **数据顺序说明醒目**：AI更容易理解数据方向
- ✅ **持仓分析更完整**：AI可以基于完整市场数据做出平仓决策

### 测试建议

1. 验证BTC是持仓币种时，BTC市场数据只在"当前持仓"部分显示一次
2. 验证BTC不是持仓币种时，BTC市场数据在"BTC市场状态"部分显示
3. 验证候选币种如果也是持仓币种，不会在"候选币种"部分重复显示
4. 验证数据顺序说明是否正确显示在开头
5. 验证所有持仓币种都包含完整市场数据

---

## 2025-11-05 - 补充4小时序列的EMA20、Volumes和BuySellRatios序列

### 问题描述
根据提示词要求，4小时序列应该与3m/15m/1h序列保持一致的数据结构，但当前实现中：
- **缺少EMA20序列**：4小时序列只有单值EMA20和EMA50，没有EMA20序列
- **缺少Volumes序列**：4小时序列只有单值CurrentVolume和AverageVolume，没有成交量序列
- **缺少BuySellRatios序列**：4小时序列完全没有买卖压力比序列

提示词明确要求（`fusion_adaptive_taro_compact.txt` 第218行）：
```
**可用数据**：3m/15m/1h/4h序列（每个30个数据点）- Mid prices, EMA20, MACD, RSI7, RSI14, Volumes, BuySellRatios
```

这说明所有4个时间框架都应该有完整的数据序列，而不是只有部分单值。

### 根本原因
1. **数据结构不完整**：
   - `LongerTermData` 结构体只定义了单值EMA（`EMA20`, `EMA50`）和单值成交量（`CurrentVolume`, `AverageVolume`）
   - 没有定义EMA20序列、Volumes序列和BuySellRatios序列字段

2. **计算逻辑不完整**：
   - `calculateLongerTermData` 函数只计算了MACD和RSI序列
   - 没有计算EMA20序列、Volumes序列和BuySellRatios序列

3. **数据格式化不完整**：
   - `Format` 函数只输出了单值EMA和成交量
   - 没有输出EMA20序列、Volumes序列和BuySellRatios序列

### 修改文件
- `market/types.go` - 扩展数据结构定义
- `market/data.go` - 修改计算和格式化逻辑

### 具体修改

#### 1. 扩展 `LongerTermData` 结构体（`market/types.go` 第40-55行）

**修改前：**
```go
type LongerTermData struct {
    EMA20         float64
    EMA50         float64
    ATR3          float64
    ATR14         float64
    CurrentVolume float64
    AverageVolume float64
    MidPrices     []float64 // 4小时价格序列
    MACDValues    []float64
    RSI7Values    []float64 // RSI7序列（提示词要求）
    RSI14Values   []float64
}
```

**修改后：**
```go
type LongerTermData struct {
    EMA20         float64   // 当前EMA20值（保留，用于兼容）
    EMA50         float64   // 当前EMA50值
    ATR3          float64
    ATR14         float64
    CurrentVolume float64   // 当前成交量（保留，用于兼容）
    AverageVolume float64   // 平均成交量（保留，用于兼容）
    MidPrices     []float64 // 4小时价格序列
    EMA20Values   []float64 // EMA20序列（新增）
    MACDValues    []float64
    RSI7Values    []float64 // RSI7序列（提示词要求）
    RSI14Values   []float64
    Volumes       []float64 // 成交量序列（新增）
    BuySellRatios []float64 // 买卖压力比序列（新增）
}
```

#### 2. 修改 `calculateLongerTermData` 函数（`market/data.go` 第285-371行）

**修改前：**
```go
func calculateLongerTermData(klines []Kline) *LongerTermData {
    data := &LongerTermData{
        MidPrices:   make([]float64, 0, 30),
        MACDValues:  make([]float64, 0, 30),
        RSI7Values:  make([]float64, 0, 30),
        RSI14Values: make([]float64, 0, 30),
    }
    
    // ... 计算单值EMA和成交量 ...
    
    for i := start; i < len(klines); i++ {
        data.MidPrices = append(data.MidPrices, klines[i].Close)
        
        // 只计算MACD和RSI序列
        // ...
    }
}
```

**修改后：**
```go
func calculateLongerTermData(klines []Kline) *LongerTermData {
    data := &LongerTermData{
        MidPrices:     make([]float64, 0, 30),
        EMA20Values:   make([]float64, 0, 30),  // 新增
        MACDValues:    make([]float64, 0, 30),
        RSI7Values:    make([]float64, 0, 30),
        RSI14Values:   make([]float64, 0, 30),
        Volumes:       make([]float64, 0, 30),  // 新增
        BuySellRatios: make([]float64, 0, 30),  // 新增
    }
    
    // ... 计算单值EMA和成交量（保留用于兼容） ...
    
    for i := start; i < len(klines); i++ {
        data.MidPrices = append(data.MidPrices, klines[i].Close)
        
        // 新增：计算成交量序列
        data.Volumes = append(data.Volumes, klines[i].Volume)
        
        // 新增：计算买卖压力比（BuySellRatio = TakerBuyBaseVolume / Volume）
        if klines[i].Volume > 0 {
            buySellRatio := klines[i].TakerBuyBaseVolume / klines[i].Volume
            data.BuySellRatios = append(data.BuySellRatios, buySellRatio)
        } else {
            data.BuySellRatios = append(data.BuySellRatios, 0.5) // 默认中性值
        }
        
        // 新增：计算每个点的EMA20序列（需要至少20个数据点）
        if i+1 >= 20 {
            ema20 := calculateEMA(klines[:i+1], 20)
            data.EMA20Values = append(data.EMA20Values, ema20)
        } else {
            data.EMA20Values = append(data.EMA20Values, 0)
        }
        
        // 计算MACD和RSI序列
        // ...
    }
}
```

#### 3. 修改 `Format` 函数（`market/data.go` 第619-645行）

**修改前：**
```go
if len(data.LongerTermContext.MidPrices) > 0 {
    sb.WriteString(fmt.Sprintf("Mid prices: %s\n\n", formatFloatSlice(data.LongerTermContext.MidPrices)))
}

if len(data.LongerTermContext.MACDValues) > 0 {
    sb.WriteString(fmt.Sprintf("MACD indicators: %s\n\n", formatFloatSlice(data.LongerTermContext.MACDValues)))
}

if len(data.LongerTermContext.RSI7Values) > 0 {
    sb.WriteString(fmt.Sprintf("RSI indicators (7‑Period): %s\n\n", formatFloatSlice(data.LongerTermContext.RSI7Values)))
}

if len(data.LongerTermContext.RSI14Values) > 0 {
    sb.WriteString(fmt.Sprintf("RSI indicators (14‑Period): %s\n\n", formatFloatSlice(data.LongerTermContext.RSI14Values)))
}
```

**修改后：**
```go
if len(data.LongerTermContext.MidPrices) > 0 {
    sb.WriteString(fmt.Sprintf("Mid prices: %s\n\n", formatFloatSlice(data.LongerTermContext.MidPrices)))
}

// 新增：输出EMA20序列
if len(data.LongerTermContext.EMA20Values) > 0 {
    sb.WriteString(fmt.Sprintf("EMA indicators (20‑period): %s\n\n", formatFloatSlice(data.LongerTermContext.EMA20Values)))
}

if len(data.LongerTermContext.MACDValues) > 0 {
    sb.WriteString(fmt.Sprintf("MACD indicators: %s\n\n", formatFloatSlice(data.LongerTermContext.MACDValues)))
}

if len(data.LongerTermContext.RSI7Values) > 0 {
    sb.WriteString(fmt.Sprintf("RSI indicators (7‑Period): %s\n\n", formatFloatSlice(data.LongerTermContext.RSI7Values)))
}

if len(data.LongerTermContext.RSI14Values) > 0 {
    sb.WriteString(fmt.Sprintf("RSI indicators (14‑Period): %s\n\n", formatFloatSlice(data.LongerTermContext.RSI14Values)))
}

// 新增：输出Volumes序列
if len(data.LongerTermContext.Volumes) > 0 {
    sb.WriteString(fmt.Sprintf("Volumes: %s\n\n", formatFloatSlice(data.LongerTermContext.Volumes)))
}

// 新增：输出BuySellRatios序列
if len(data.LongerTermContext.BuySellRatios) > 0 {
    sb.WriteString(fmt.Sprintf("BuySellRatios (>0.6多方强, <0.4空方强): %s\n\n", formatFloatSlice(data.LongerTermContext.BuySellRatios)))
}
```

### 修改说明
1. **数据结构扩展**：
   - 添加了 `EMA20Values`、`Volumes`、`BuySellRatios` 序列字段
   - 保留了单值EMA和成交量字段（用于兼容现有代码）

2. **计算逻辑扩展**：
   - 在循环中计算每个数据点的EMA20序列（使用与3m/15m/1h相同的逻辑）
   - 计算成交量序列（直接从K线数据提取）
   - 计算买卖压力比序列（TakerBuyBaseVolume / Volume）

3. **数据格式化扩展**：
   - 输出EMA20序列
   - 输出Volumes序列
   - 输出BuySellRatios序列（包含说明）

4. **数组长度一致性**：
   - 所有序列都使用相同的长度（30个数据点）
   - 数据不足时填充0，保持数组长度一致

### 数据完整性对比

| 数据项 | 3m/15m/1h序列 | 4小时序列（修改前） | 4小时序列（修改后） |
|--------|--------------|-------------------|-------------------|
| Mid prices | ✅ 30个数据点 | ✅ 30个数据点 | ✅ 30个数据点 |
| EMA20序列 | ✅ 30个数据点 | ❌ 只有单值 | ✅ 30个数据点 |
| MACD序列 | ✅ 30个数据点 | ✅ 30个数据点 | ✅ 30个数据点 |
| RSI7序列 | ✅ 30个数据点 | ✅ 30个数据点 | ✅ 30个数据点 |
| RSI14序列 | ✅ 30个数据点 | ✅ 30个数据点 | ✅ 30个数据点 |
| Volumes序列 | ✅ 30个数据点 | ❌ 只有单值 | ✅ 30个数据点 |
| BuySellRatios序列 | ✅ 30个数据点 | ❌ 缺失 | ✅ 30个数据点 |

### 影响范围
- ✅ 4小时序列现在与3m/15m/1h序列结构完全一致
- ✅ 符合提示词要求的所有数据项
- ✅ AI可以进行完整的4小时序列分析（包括EMA20趋势、成交量放量、买卖压力比）
- ✅ 保留了单值EMA和成交量字段（向后兼容）
- ✅ 所有4个时间框架的数据结构统一，便于AI进行多周期分析

### 测试建议
1. 验证4小时序列的所有数组长度都是30个数据点
2. 验证EMA20序列计算正确（与单值EMA20最后的值应该一致）
3. 验证Volumes序列包含30个成交量数据点
4. 验证BuySellRatios序列计算正确（值在0-1之间）
5. 验证Format函数输出包含所有新增序列

---

## 2025-11-05 - 修复EMA/MACD/RSI序列计算逻辑问题（数组长度不一致）

### 问题描述
在 `calculateIntradaySeries` 和 `calculateLongerTermData` 函数中，使用绝对索引（如 `i >= 19`）来判断是否有足够的数据计算指标，导致：
- **数组长度不一致**：当数据少于30个时，前几个元素没有指标值（EMA20、MACD、RSI等），但 `MidPrices` 总是添加所有元素
- **判断逻辑错误**：使用 `i >= 19` 来判断是否有20个数据点是不正确的，应该是 `i+1 >= 20`
- **数据不足时处理不当**：跳过添加值而不是填充默认值，导致AI收到的数据格式不一致

### 根本原因
1. **索引判断错误**：
   - `i` 是循环变量（从 `start` 开始），使用 `i >= 19` 判断的是绝对索引位置
   - 应该判断的是从数组开头到当前位置有多少个数据点：`i+1 >= period`

2. **数组长度不一致**：
   - `MidPrices` 总是添加（30个元素）
   - `EMA20Values` 只在 `i >= 19` 时添加（可能少于30个）
   - 如果 `start = 0` 且只有15个K线，`EMA20Values` 会是0个元素

3. **示例问题场景**：
   - 如果有100个K线，`start = 70`：所有30个元素都有指标值 ✅
   - 如果只有15个K线，`start = 0`：前19个元素没有EMA20，导致数组长度不一致 ❌

### 修改文件
- `market/data.go`

### 具体修改

#### 1. 修复 `calculateIntradaySeries` 函数（第233-280行）

**修改前：**
```go
for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    
    // 计算每个点的EMA20
    if i >= 19 {
        ema20 := calculateEMA(klines[:i+1], 20)
        data.EMA20Values = append(data.EMA20Values, ema20)
    }
    
    // 计算每个点的MACD
    if i >= 25 {
        macd := calculateMACD(klines[:i+1])
        data.MACDValues = append(data.MACDValues, macd)
    }
    
    // 计算每个点的RSI
    if i >= 7 {
        rsi7 := calculateRSI(klines[:i+1], 7)
        data.RSI7Values = append(data.RSI7Values, rsi7)
    }
    if i >= 14 {
        rsi14 := calculateRSI(klines[:i+1], 14)
        data.RSI14Values = append(data.RSI14Values, rsi14)
    }
}
```

**修改后：**
```go
for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    
    // 计算每个点的EMA20（需要至少20个数据点）
    // i+1 表示从数组开头到当前位置总共有多少个数据点
    if i+1 >= 20 {
        ema20 := calculateEMA(klines[:i+1], 20)
        data.EMA20Values = append(data.EMA20Values, ema20)
    } else {
        // 没有足够数据时，添加0以保持数组长度一致
        data.EMA20Values = append(data.EMA20Values, 0)
    }
    
    // 计算每个点的MACD（需要至少26个数据点）
    if i+1 >= 26 {
        macd := calculateMACD(klines[:i+1])
        data.MACDValues = append(data.MACDValues, macd)
    } else {
        data.MACDValues = append(data.MACDValues, 0)
    }
    
    // 计算每个点的RSI7（需要至少8个数据点）
    if i+1 >= 8 {
        rsi7 := calculateRSI(klines[:i+1], 7)
        data.RSI7Values = append(data.RSI7Values, rsi7)
    } else {
        data.RSI7Values = append(data.RSI7Values, 0)
    }
    
    // 计算每个点的RSI14（需要至少15个数据点）
    if i+1 >= 15 {
        rsi14 := calculateRSI(klines[:i+1], 14)
        data.RSI14Values = append(data.RSI14Values, rsi14)
    } else {
        data.RSI14Values = append(data.RSI14Values, 0)
    }
}
```

#### 2. 修复 `calculateLongerTermData` 函数（第319-346行）

**修改前：**
```go
for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    
    // 计算MACD序列
    if i >= 25 {
        macd := calculateMACD(klines[:i+1])
        data.MACDValues = append(data.MACDValues, macd)
    }
    
    // 计算RSI7序列
    if i >= 7 {
        rsi7 := calculateRSI(klines[:i+1], 7)
        data.RSI7Values = append(data.RSI7Values, rsi7)
    }
    
    // 计算RSI14序列
    if i >= 14 {
        rsi14 := calculateRSI(klines[:i+1], 14)
        data.RSI14Values = append(data.RSI14Values, rsi14)
    }
}
```

**修改后：**
```go
for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    
    // 计算MACD序列（需要至少26个数据点）
    if i+1 >= 26 {
        macd := calculateMACD(klines[:i+1])
        data.MACDValues = append(data.MACDValues, macd)
    } else {
        data.MACDValues = append(data.MACDValues, 0)
    }
    
    // 计算RSI7序列（需要至少8个数据点）
    if i+1 >= 8 {
        rsi7 := calculateRSI(klines[:i+1], 7)
        data.RSI7Values = append(data.RSI7Values, rsi7)
    } else {
        data.RSI7Values = append(data.RSI7Values, 0)
    }
    
    // 计算RSI14序列（需要至少15个数据点）
    if i+1 >= 15 {
        rsi14 := calculateRSI(klines[:i+1], 14)
        data.RSI14Values = append(data.RSI14Values, rsi14)
    } else {
        data.RSI14Values = append(data.RSI14Values, 0)
    }
}
```

### 修改说明
1. **正确的判断逻辑**：
   - 从 `i >= period-1` 改为 `i+1 >= period`
   - `i+1` 表示从数组开头到当前位置总共有多少个数据点
   - 这样可以正确判断是否有足够的历史数据来计算指标

2. **数组长度一致性**：
   - 数据不足时不再跳过，而是添加 `0` 作为占位符
   - 确保所有数组（`MidPrices`、`EMA20Values`、`MACDValues`、`RSI7Values`、`RSI14Values`）长度一致
   - AI可以识别 `0` 值表示数据不足，而不是数组长度不一致导致的解析错误

3. **为什么使用 `klines[:i+1]`**：
   - EMA/MACD/RSI需要从历史数据开始累积计算
   - `klines[:i+1]` 提供从数组开头到当前位置的所有历史数据
   - 不能只使用窗口内的数据，否则指标计算不准确

### 修复前后对比

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| **数据充足（100个K线）** |
| `MidPrices` 长度 | 30 | 30 |
| `EMA20Values` 长度 | 30 | 30 |
| `MACDValues` 长度 | 30 | 30 |
| `RSI7Values` 长度 | 30 | 30 |
| `RSI14Values` 长度 | 30 | 30 |
| ✅ 数组长度一致 | ✅ | ✅ |
| **数据不足（15个K线）** |
| `MidPrices` 长度 | 15 | 15 |
| `EMA20Values` 长度 | 0（错误） | 15（前15个为0） |
| `MACDValues` 长度 | 0（错误） | 15（前15个为0） |
| `RSI7Values` 长度 | 9（错误） | 15（前7个为0） |
| `RSI14Values` 长度 | 2（错误） | 15（前14个为0） |
| ❌ 数组长度不一致 | ✅ 数组长度一致 |

### 影响范围
- ✅ 修复了数组长度不一致的问题
- ✅ 修复了判断逻辑错误（`i >= 19` → `i+1 >= 20`）
- ✅ 确保所有指标数组长度与价格数组一致
- ✅ AI可以正确处理数据不足的情况（通过识别0值）
- ✅ 不影响数据充足时的正常计算

### 测试建议
1. 测试数据充足情况（100个K线）：验证所有数组长度都是30
2. 测试数据不足情况（15个K线）：验证所有数组长度都是15，前几个元素为0
3. 验证指标计算正确性：数据充足时，指标值应该与修复前一致
4. 验证AI能正确处理0值：确认AI可以识别数据不足的情况

---

## 2025-11-05 - 增加AI数据点数量（从10个增加到30个）

### 问题描述
提示词要求"每个包含最近10个数据点"，但10个数据点对于量化交易AI来说太少了，限制了AI的分析能力：
- **趋势识别不足**：10个数据点难以识别完整的趋势周期
- **形态识别受限**：无法识别双顶、头肩顶等重要形态（需要15-30个K线）
- **震荡区间识别困难**：无法看到完整的震荡区间边界
- **指标分析受限**：无法看到指标的完整演变过程，难以判断背离
- **多周期分析受限**：提示词要求多周期分析，但每个周期只有10个数据点

### 根本原因
1. **时间覆盖不足**：
   - 3分钟×10 = 30分钟（难以识别短期趋势）
   - 15分钟×10 = 2.5小时（可能看不到完整震荡周期）
   - 1小时×10 = 10小时（无法覆盖完整日线周期）
   - 4小时×10 = 40小时（无法识别周线级别趋势）

2. **形态识别需要更多数据**：
   - 双顶/双底：至少需要15-20个数据点
   - 头肩顶/头肩底：需要20-30个数据点
   - 三角形整理：需要15-25个数据点

3. **AI分析能力受限**：
   - 无法识别完整的趋势周期（启动、延续、衰竭）
   - 无法判断指标的完整演变过程
   - 无法进行有效的多周期深度分析

### 修改文件
- `market/data.go`
- `prompts/fusion_adaptive_taro.txt`
- `prompts/fusion_adaptive_taro_compact.txt`

### 具体修改

#### 1. 修改 `calculateIntradaySeries` 函数（`market/data.go` 第215-271行）

**修改前：**
```go
data := &IntradayData{
    MidPrices:     make([]float64, 0, 10),
    EMA20Values:   make([]float64, 0, 10),
    MACDValues:    make([]float64, 0, 10),
    RSI7Values:    make([]float64, 0, 10),
    RSI14Values:   make([]float64, 0, 10),
    Volumes:       make([]float64, 0, 10),
    BuySellRatios: make([]float64, 0, 10),
}

// 获取最近10个数据点
start := len(klines) - 10
```

**修改后：**
```go
data := &IntradayData{
    MidPrices:     make([]float64, 0, 30),
    EMA20Values:   make([]float64, 0, 30),
    MACDValues:    make([]float64, 0, 30),
    RSI7Values:    make([]float64, 0, 30),
    RSI14Values:   make([]float64, 0, 30),
    Volumes:       make([]float64, 0, 30),
    BuySellRatios: make([]float64, 0, 30),
}

// 获取最近30个数据点（用于AI深度分析）
start := len(klines) - 30
```

#### 2. 修改 `calculateLongerTermData` 函数（`market/data.go` 第273-331行）

**修改前：**
```go
data := &LongerTermData{
    MidPrices:   make([]float64, 0, 10),
    MACDValues:  make([]float64, 0, 10),
    RSI7Values:  make([]float64, 0, 10),
    RSI14Values: make([]float64, 0, 10),
}

// 计算MACD和RSI序列
start := len(klines) - 10
```

**修改后：**
```go
data := &LongerTermData{
    MidPrices:   make([]float64, 0, 30),
    MACDValues:  make([]float64, 0, 30),
    RSI7Values:  make([]float64, 0, 30),
    RSI14Values: make([]float64, 0, 30),
}

// 计算MACD和RSI序列（获取最近30个数据点用于AI深度分析）
start := len(klines) - 30
```

#### 3. 更新 `Get` 函数注释（`market/data.go` 第19-38行）

**修改前：**
```go
// 获取3分钟K线数据（获取100个用于计算指标，最后10个传递给AI）
klines3m, err = WSMonitorCli.GetCurrentKlines(symbol, "3m")
```

**修改后：**
```go
// 获取3分钟K线数据（获取100个用于计算指标，最后30个传递给AI）
klines3m, err = WSMonitorCli.GetCurrentKlines(symbol, "3m")
```

同样更新了15分钟、1小时、4小时K线的注释。

#### 4. 更新提示词文件

**`prompts/fusion_adaptive_taro.txt` 第615行：**

**修改前：**
```
**📊 四个时间框架序列**（每个包含最近10个数据点）：
2. **15分钟序列**：短期震荡区间识别（覆盖最近2.5小时）
3. **1小时序列**：中期支撑压力确认（覆盖最近10小时）
4. **4小时序列**：大趋势预警（覆盖最近40小时）
```

**修改后：**
```
**📊 四个时间框架序列**（每个包含最近30个数据点）：
2. **15分钟序列**：短期震荡区间识别（覆盖最近7.5小时）
3. **1小时序列**：中期支撑压力确认（覆盖最近30小时）
4. **4小时序列**：大趋势预警（覆盖最近120小时，约5天）
```

**`prompts/fusion_adaptive_taro_compact.txt` 第218行：**

**修改前：**
```
**可用数据**：3m/15m/1h/4h序列（每个10个数据点）- Mid prices, EMA20, MACD, RSI7, RSI14, Volumes, BuySellRatios
```

**修改后：**
```
**可用数据**：3m/15m/1h/4h序列（每个30个数据点）- Mid prices, EMA20, MACD, RSI7, RSI14, Volumes, BuySellRatios
```

### 修改说明
1. **数据结构容量调整**：
   - 所有序列的容量从10调整为30
   - 确保有足够的空间存储30个数据点

2. **数据点提取逻辑**：
   - 从 `len(klines) - 10` 改为 `len(klines) - 30`
   - 如果K线数据少于30个，会使用所有可用数据（`start = 0`）

3. **指标计算逻辑不变**：
   - 指标计算仍然使用完整的100个数据点，确保准确性
   - 只有传递给AI的序列包含30个数据点

4. **提示词同步更新**：
   - 更新时间框架描述，说明每个包含30个数据点
   - 更新时间覆盖范围说明

### 数据量对比

| 时间框架 | 修改前 | 修改后 | 时间覆盖提升 |
|---------|--------|--------|------------|
| 3分钟   | 10个 | **30个** | 30分钟 → **1.5小时** |
| 15分钟  | 10个 | **30个** | 2.5小时 → **7.5小时** |
| 1小时   | 10个 | **30个** | 10小时 → **30小时（1.25天）** |
| 4小时   | 10个 | **30个** | 40小时 → **120小时（5天）** |

### 预期效果提升
1. ✅ **趋势识别能力**：30个数据点足够识别完整的趋势周期（启动、延续、衰竭）
2. ✅ **形态识别能力**：可以识别双顶、头肩顶、三角形整理等重要形态
3. ✅ **震荡区间识别**：可以看到完整的震荡区间上下边界
4. ✅ **指标分析能力**：可以看到指标的完整演变过程，识别背离
5. ✅ **多周期分析能力**：每个时间框架都有足够的数据进行深度分析

### Token消耗影响
- **修改前**：约 2,800 tokens（4个时间框架 × 10个数据点）
- **修改后**：约 8,400 tokens（4个时间框架 × 30个数据点）
- **增加倍数**：约3倍
- **成本影响**：Token消耗增加，但AI分析能力显著提升，可能带来更好的交易决策

### 影响范围
- ✅ 提升AI的分析能力（3倍数据量）
- ✅ 能够识别更多形态和趋势
- ✅ 改善交易决策质量
- ✅ 符合提示词要求的"自主模式识别"和"多周期趋势确认"
- ⚠️ Token消耗增加约3倍（成本增加）

### 测试建议
1. 验证每个时间框架的数据点数量是否确实是30个
2. 监控Token消耗，评估成本影响
3. 对比交易效果，评估决策质量提升
4. 确认AI能够识别更多形态和趋势

---

## 2025-11-05 - 改进OI平均值计算逻辑

### 问题描述
在 `getOpenInterestData` 函数中，使用 `Latest * 0.999` 作为平均OI的近似值，这不是真正的历史平均值，只是一个占位符。如果历史数据获取失败，变化百分比总是约0.1%，没有实际意义，可能影响AI对OI变化的判断（提示词要求OI变化>+5%）。

### 根本原因
1. **假平均值**：`Latest * 0.999` 不是真正的历史平均值，只是当前值的99.9%
2. **降级策略不合理**：如果历史数据获取失败，使用假的平均值计算变化百分比（总是约0.1%），误导AI判断
3. **历史数据获取不充分**：只获取1个历史数据点（period=5m, limit=1），无法计算真实平均值

### 修改文件
- `market/data.go`

### 具体修改

#### 修改 `getOpenInterestData` 函数（第333-415行）

**修改前：**
```go
// 计算平均OI（使用当前值作为近似，如果有历史数据可以改进）
oiAverage := oiLatest * 0.999 // 近似平均值

// 尝试获取历史OI数据来计算变化百分比
// Binance的openInterestHist接口需要指定时间范围，这里使用简化的方法
// 获取24小时前的OI数据（如果有的话）
oiDeltaPercent := 0.0
histURL := fmt.Sprintf("https://fapi.binance.com/fapi/v1/openInterestHist?symbol=%s&period=5m&limit=1", symbol)
histResp, histErr := http.Get(histURL)
if histErr == nil {
    defer histResp.Body.Close()
    histBody, _ := io.ReadAll(histResp.Body)
    var histResult []struct {
        SumOpenInterest string `json:"sumOpenInterest"`
        SumOpenInterestValue string `json:"sumOpenInterestValue"`
    }
    if json.Unmarshal(histBody, &histResult) == nil && len(histResult) > 0 {
        if histOI, parseErr := strconv.ParseFloat(histResult[0].SumOpenInterest, 64); parseErr == nil && histOI > 0 {
            oiDeltaPercent = ((oiLatest - histOI) / histOI) * 100
        }
    }
}

// 如果无法获取历史数据，使用当前值和平均值的差异作为近似
if oiDeltaPercent == 0 && oiAverage > 0 {
    oiDeltaPercent = ((oiLatest - oiAverage) / oiAverage) * 100
}
```

**修改后：**
```go
// 尝试获取历史OI数据来计算变化百分比和平均值
oiDeltaPercent := 0.0
oiAverage := oiLatest // 默认使用当前值作为平均值（如果无法获取历史数据）

// 获取24小时的历史OI数据（每1小时一个数据点，共24个）
histURL := fmt.Sprintf("https://fapi.binance.com/fapi/v1/openInterestHist?symbol=%s&period=1h&limit=24", symbol)
histResp, histErr := http.Get(histURL)
if histErr == nil {
    defer histResp.Body.Close()
    histBody, _ := io.ReadAll(histResp.Body)
    var histResult []struct {
        SumOpenInterest      string `json:"sumOpenInterest"`
        SumOpenInterestValue string `json:"sumOpenInterestValue"`
    }
    if json.Unmarshal(histBody, &histResult) == nil && len(histResult) > 0 {
        // 计算平均值（使用所有历史数据点）
        sum := 0.0
        validCount := 0
        for _, item := range histResult {
            if histOI, parseErr := strconv.ParseFloat(item.SumOpenInterest, 64); parseErr == nil && histOI > 0 {
                sum += histOI
                validCount++
            }
        }

        if validCount > 0 {
            oiAverage = sum / float64(validCount)

            // 计算变化百分比（使用最早的历史数据，即24小时前）
            // 历史数据按时间倒序排列，第一个是最早的
            earliestOIStr := histResult[len(histResult)-1].SumOpenInterest
            if earliestOI, parseErr := strconv.ParseFloat(earliestOIStr, 64); parseErr == nil && earliestOI > 0 {
                oiDeltaPercent = ((oiLatest - earliestOI) / earliestOI) * 100
            } else if len(histResult) > 0 {
                // 如果最后一个解析失败，尝试第一个
                if firstOI, parseErr := strconv.ParseFloat(histResult[0].SumOpenInterest, 64); parseErr == nil && firstOI > 0 {
                    oiDeltaPercent = ((oiLatest - firstOI) / firstOI) * 100
                }
            }
        }
    }
}

// 如果无法获取历史数据或历史数据无效，使用当前值作为平均值
// 但不设置假的DeltaPercent（保持为0），让AI知道这是当前数据，无法判断变化
if oiDeltaPercent == 0 && oiAverage == oiLatest {
    // 这种情况下，我们无法知道真实的变化，DeltaPercent保持为0
    // 这意味着AI应该忽略OI变化这个指标，或者使用其他指标
}
```

### 修改说明
1. **获取真实历史数据**：
   - 从获取1个数据点改为获取24个数据点（24小时历史，每1小时一个）
   - 使用所有历史数据点计算真实的平均值

2. **计算真实平均值**：
   - 遍历所有历史数据点，累加并计算平均值
   - 不再使用 `Latest * 0.999` 这样的假值

3. **改进变化百分比计算**：
   - 使用最早的历史数据（24小时前）计算变化百分比
   - 如果最早的数据解析失败，尝试使用第一个数据点

4. **合理的降级策略**：
   - 如果无法获取历史数据，使用当前值作为平均值
   - **关键改进**：不再设置假的DeltaPercent（保持为0），让AI知道这是当前数据，无法判断变化
   - 这样AI可以忽略OI变化这个指标，或者使用其他指标进行判断

### 影响范围
- ✅ 修复了使用假平均值的问题，现在使用真实的历史平均值
- ✅ 修复了假变化百分比的问题，如果无法获取历史数据，DeltaPercent保持为0
- ✅ 提高了OI数据计算的准确性，基于24小时的历史数据
- ✅ 不影响其他功能的正常运行
- ✅ 改善了AI对OI变化的判断（提示词要求OI变化>+5%）

### 测试建议
1. 测试正常情况：验证能正确获取24小时历史OI数据并计算平均值
2. 测试网络异常：验证历史数据获取失败时，DeltaPercent保持为0（而不是假的0.1%）
3. 验证AI决策：检查AI是否能正确使用OI变化百分比（>+5%）进行多空确认
4. 检查日志：确认没有出现假的0.1%变化百分比

---

## 2025-11-05 - 补全提示词所需的所有数据（数据需求完整性修复）

### 问题描述
根据 `fusion_adaptive_taro.txt` 提示词的分析，发现系统缺少大量关键数据，导致AI无法按照提示词要求进行分析：
- **15分钟序列完全缺失**：提示词要求多周期分析（3m/15m/1h/4h），但只有3m和4h
- **1小时序列完全缺失**：无法进行中期支撑压力确认
- **BTC多周期MACD缺失**：提示词要求检查BTC的15m/1h/4h MACD方向，但只有4h
- **买卖压力比（BuySellRatios）缺失**：无法进行多空确认清单第4项判断
- **成交量序列缺失**：无法检测放量（>1.5x均量）和判断假突破
- **OI变化百分比缺失**：无法判断"OI变化>+5%"（多空确认清单第8项）
- **4小时RSI7序列缺失**：提示词要求4小时序列有RSI7和RSI14，但只有RSI14

### 根本原因
1. **数据结构不完整**：
   - `Data` 结构只有 `IntradaySeries`（3分钟）和 `LongerTermContext`（4小时）
   - 缺少 `Series15m` 和 `Series1h` 字段
   - `IntradayData` 缺少 `Volumes` 和 `BuySellRatios` 字段
   - `LongerTermData` 缺少 `MidPrices` 和 `RSI7Values` 字段
   - `OIData` 缺少 `DeltaPercent` 字段

2. **数据获取不完整**：
   - `Get()` 函数只获取3m和4h的K线数据
   - 没有获取15m和1h的K线数据
   - BTC数据只提供基本信息，没有完整的多周期数据

3. **指标计算不完整**：
   - `calculateIntradaySeries` 没有计算Volumes和BuySellRatios序列
   - `calculateLongerTermData` 没有计算RSI7序列和MidPrices序列
   - `getOpenInterestData` 没有计算OI变化百分比

### 修改文件
- `market/types.go` - 扩展数据结构定义
- `market/data.go` - 修改数据获取、计算和格式化逻辑
- `decision/engine.go` - 修改BTC数据显示

### 具体修改

#### 1. 扩展数据结构（`market/types.go`）

**修改 `Data` 结构体：**
```go
// 修改前
type Data struct {
    // ...
    IntradaySeries    *IntradayData
    LongerTermContext *LongerTermData
}

// 修改后
type Data struct {
    // ...
    IntradaySeries    *IntradayData // 3分钟序列
    Series15m         *IntradayData // 15分钟序列
    Series1h          *IntradayData // 1小时序列
    LongerTermContext *LongerTermData
}
```

**修改 `IntradayData` 结构体：**
```go
// 修改前
type IntradayData struct {
    MidPrices   []float64
    EMA20Values []float64
    MACDValues  []float64
    RSI7Values  []float64
    RSI14Values []float64
}

// 修改后
type IntradayData struct {
    MidPrices      []float64
    EMA20Values    []float64
    MACDValues     []float64
    RSI7Values     []float64
    RSI14Values    []float64
    Volumes        []float64 // 成交量序列
    BuySellRatios  []float64 // 买卖压力比序列（TakerBuyBaseVolume / Volume）
}
```

**修改 `LongerTermData` 结构体：**
```go
// 修改前
type LongerTermData struct {
    // ...
    MACDValues    []float64
    RSI14Values   []float64
}

// 修改后
type LongerTermData struct {
    // ...
    MidPrices     []float64 // 4小时价格序列
    MACDValues    []float64
    RSI7Values    []float64 // RSI7序列（提示词要求）
    RSI14Values   []float64
}
```

**修改 `OIData` 结构体：**
```go
// 修改前
type OIData struct {
    Latest  float64
    Average float64
}

// 修改后
type OIData struct {
    Latest      float64
    Average     float64
    DeltaPercent float64 // OI变化百分比（用于判断>+5%）
}
```

#### 2. 修改数据获取函数（`market/data.go`）

**修改 `Get` 函数：添加15m和1h数据获取**
```go
// 修改前
var klines3m, klines4h []Kline

// 修改后
var klines3m, klines15m, klines1h, klines4h []Kline

// 获取15分钟K线数据
klines15m, err = WSMonitorCli.GetCurrentKlines(symbol, "15m")
// 获取1小时K线数据
klines1h, err = WSMonitorCli.GetCurrentKlines(symbol, "1h")

// 计算各时间框架的系列数据
intradayData := calculateIntradaySeries(klines3m)   // 3分钟序列
series15m := calculateIntradaySeries(klines15m)     // 15分钟序列
series1h := calculateIntradaySeries(klines1h)       // 1小时序列
longerTermData := calculateLongerTermData(klines4h) // 4小时序列

return &Data{
    // ...
    IntradaySeries:    intradayData,
    Series15m:         series15m,
    Series1h:          series1h,
    LongerTermContext: longerTermData,
}
```

**修改 `calculateIntradaySeries` 函数：添加Volumes和BuySellRatios计算**
```go
// 修改前
data := &IntradayData{
    MidPrices:     make([]float64, 0, 10),
    EMA20Values:   make([]float64, 0, 10),
    MACDValues:    make([]float64, 0, 10),
    RSI7Values:    make([]float64, 0, 10),
    RSI14Values:   make([]float64, 0, 10),
}

for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    // ... 其他指标计算
}

// 修改后
data := &IntradayData{
    MidPrices:     make([]float64, 0, 10),
    EMA20Values:   make([]float64, 0, 10),
    MACDValues:    make([]float64, 0, 10),
    RSI7Values:    make([]float64, 0, 10),
    RSI14Values:   make([]float64, 0, 10),
    Volumes:       make([]float64, 0, 10),      // 新增：成交量序列
    BuySellRatios: make([]float64, 0, 10),      // 新增：买卖压力比序列
}

for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    
    // 新增：计算成交量序列
    data.Volumes = append(data.Volumes, klines[i].Volume)
    
    // 新增：计算买卖压力比（BuySellRatio = TakerBuyBaseVolume / Volume）
    if klines[i].Volume > 0 {
        buySellRatio := klines[i].TakerBuyBaseVolume / klines[i].Volume
        data.BuySellRatios = append(data.BuySellRatios, buySellRatio)
    } else {
        data.BuySellRatios = append(data.BuySellRatios, 0.5) // 默认中性值
    }
    // ... 其他指标计算
}
```

**修改 `calculateLongerTermData` 函数：添加RSI7序列和MidPrices序列**
```go
// 修改前
data := &LongerTermData{
    MACDValues:  make([]float64, 0, 10),
    RSI14Values: make([]float64, 0, 10),
}

// 修改后
data := &LongerTermData{
    MidPrices:   make([]float64, 0, 10),  // 新增：4小时价格序列
    MACDValues:  make([]float64, 0, 10),
    RSI7Values:  make([]float64, 0, 10),  // 新增：RSI7序列
    RSI14Values: make([]float64, 0, 10),
}

// 在循环中添加价格序列和RSI7序列
for i := start; i < len(klines); i++ {
    data.MidPrices = append(data.MidPrices, klines[i].Close)
    // ... 其他指标计算
    // 新增：计算RSI7序列
    if i >= 7 {
        rsi7 := calculateRSI(klines[:i+1], 7)
        data.RSI7Values = append(data.RSI7Values, rsi7)
    }
    // ...
}
```

**修改 `getOpenInterestData` 函数：添加DeltaPercent字段**
```go
// 修改前
return &OIData{
    Latest:  oiLatest,
    Average: oiLatest * 0.999, // 近似平均值
}

// 修改后
// 注意：OI平均值和变化百分比的计算逻辑改进请参考"改进OI平均值计算逻辑"条目
return &OIData{
    Latest:      oiLatest,
    Average:     oiAverage,      // 改进后的真实历史平均值（见单独日志条目）
    DeltaPercent: oiDeltaPercent, // 新增：OI变化百分比字段
}
```

#### 3. 修改数据格式化函数（`market/data.go`）

**修改 `Format` 函数：输出所有新数据**
```go
// 添加15分钟序列输出
if data.Series15m != nil {
    sb.WriteString("15-minute series (oldest → latest):\n\n")
    // 输出Mid prices, EMA20, MACD, RSI7, RSI14, Volumes, BuySellRatios
}

// 添加1小时序列输出
if data.Series1h != nil {
    sb.WriteString("1-hour series (oldest → latest):\n\n")
    // 输出Mid prices, EMA20, MACD, RSI7, RSI14, Volumes, BuySellRatios
}

// 更新3分钟序列输出：添加Volumes和BuySellRatios
if len(data.IntradaySeries.Volumes) > 0 {
    sb.WriteString(fmt.Sprintf("Volumes: %s\n\n", formatFloatSlice(data.IntradaySeries.Volumes)))
}
if len(data.IntradaySeries.BuySellRatios) > 0 {
    sb.WriteString(fmt.Sprintf("BuySellRatios (>0.6多方强, <0.4空方强): %s\n\n", formatFloatSlice(data.IntradaySeries.BuySellRatios)))
}

// 更新4小时序列输出：添加MidPrices和RSI7序列
if len(data.LongerTermContext.MidPrices) > 0 {
    sb.WriteString(fmt.Sprintf("Mid prices: %s\n\n", formatFloatSlice(data.LongerTermContext.MidPrices)))
}
if len(data.LongerTermContext.RSI7Values) > 0 {
    sb.WriteString(fmt.Sprintf("RSI indicators (7‑Period): %s\n\n", formatFloatSlice(data.LongerTermContext.RSI7Values)))
}

// 更新OI输出：添加变化百分比
sb.WriteString(fmt.Sprintf("Open Interest: Latest: %.2f Average: %.2f Delta: %.2f%%\n\n",
    data.OpenInterest.Latest, data.OpenInterest.Average, data.OpenInterest.DeltaPercent))
```

#### 4. 修改BTC数据显示（`decision/engine.go`）

**修改 `buildUserPrompt` 函数：**
```go
// 修改前
if btcData, hasBTC := ctx.MarketDataMap["BTCUSDT"]; hasBTC {
    sb.WriteString(fmt.Sprintf("BTC: %.2f (1h: %+.2f%%, 4h: %+.2f%%) | MACD: %.4f | RSI: %.2f\n\n",
        btcData.CurrentPrice, btcData.PriceChange1h, btcData.PriceChange4h,
        btcData.CurrentMACD, btcData.CurrentRSI7))
}

// 修改后
if btcData, hasBTC := ctx.MarketDataMap["BTCUSDT"]; hasBTC {
    sb.WriteString("## BTC市场状态（用于BTC状态检查和多周期分析）\n\n")
    sb.WriteString(market.Format(btcData))
    sb.WriteString("\n")
}
```

### 修改说明
1. **数据结构扩展**：
   - 添加了 `Series15m` 和 `Series1h` 字段支持15m和1h序列
   - 在 `IntradayData` 中添加了 `Volumes` 和 `BuySellRatios` 字段
   - 在 `LongerTermData` 中添加了 `MidPrices` 和 `RSI7Values` 字段
   - 在 `OIData` 中添加了 `DeltaPercent` 字段

2. **数据获取扩展**：
   - `Get()` 函数现在获取4个时间框架的数据（3m、15m、1h、4h）
   - 每个时间框架都通过 `calculateIntradaySeries` 或 `calculateLongerTermData` 计算完整指标

3. **指标计算扩展**：
   - `calculateIntradaySeries` 现在计算Volumes和BuySellRatios序列
   - `calculateLongerTermData` 现在计算MidPrices和RSI7序列
   - `getOpenInterestData` 添加了DeltaPercent字段（OI平均值计算改进见单独日志条目）

4. **数据格式化扩展**：
   - `Format()` 函数输出所有时间框架的完整数据
   - 包含Volumes、BuySellRatios、OI变化百分比等新数据

5. **BTC数据完整性**：
   - BTC现在通过 `market.Format()` 输出完整的多周期数据
   - 包含3m/15m/1h/4h序列，满足BTC状态检查要求

### 数据完整性对比

| 数据项 | 提示词要求 | 修改前 | 修改后 |
|--------|-----------|--------|--------|
| **3分钟序列** |
| Mid prices | ✅ 10个数据点 | ✅ | ✅ |
| EMA20 | ✅ 10个数据点 | ✅ | ✅ |
| MACD | ✅ 10个数据点 | ✅ | ✅ |
| RSI7 | ✅ 10个数据点 | ✅ | ✅ |
| RSI14 | ✅ 10个数据点 | ✅ | ✅ |
| Volumes | ✅ 10个数据点 | ❌ | ✅ |
| BuySellRatios | ✅ 10个数据点 | ❌ | ✅ |
| **15分钟序列** |
| Mid prices | ✅ 10个数据点 | ❌ | ✅ |
| EMA20 | ✅ 10个数据点 | ❌ | ✅ |
| MACD | ✅ 10个数据点 | ❌ | ✅ |
| RSI7 | ✅ 10个数据点 | ❌ | ✅ |
| RSI14 | ✅ 10个数据点 | ❌ | ✅ |
| Volumes | ✅ 10个数据点 | ❌ | ✅ |
| BuySellRatios | ✅ 10个数据点 | ❌ | ✅ |
| **1小时序列** |
| Mid prices | ✅ 10个数据点 | ❌ | ✅ |
| EMA20 | ✅ 10个数据点 | ❌ | ✅ |
| MACD | ✅ 10个数据点 | ❌ | ✅ |
| RSI7 | ✅ 10个数据点 | ❌ | ✅ |
| RSI14 | ✅ 10个数据点 | ❌ | ✅ |
| Volumes | ✅ 10个数据点 | ❌ | ✅ |
| BuySellRatios | ✅ 10个数据点 | ❌ | ✅ |
| **4小时序列** |
| Mid prices | ✅ 10个数据点 | ❌ | ✅ |
| EMA20 | ✅ | ✅ | ✅ |
| EMA50 | ✅ | ✅ | ✅ |
| MACD | ✅ 10个数据点 | ✅ | ✅ |
| RSI7 | ✅ 10个数据点 | ❌ | ✅ |
| RSI14 | ✅ 10个数据点 | ✅ | ✅ |
| ATR | ✅ | ✅ | ✅ |
| Volume | ✅ | ✅ | ✅ |
| **BTC状态检查** |
| BTC 15m MACD | ✅ 必需 | ❌ | ✅ |
| BTC 1h MACD | ✅ 必需 | ❌ | ✅ |
| BTC 4h MACD | ✅ 必需 | ✅ | ✅ |
| **其他数据** |
| OI变化百分比字段 | ✅ 必需 | ❌ | ✅ |
| OI平均值计算 | ✅ 必需 | ⚠️ 近似值 | ✅ 真实值（见单独日志） |
| 资金费率 | ✅ | ✅ | ✅ |

**注意**：数据点数量从10个增加到30个的修改请参考"增加AI数据点数量"日志条目。OI平均值计算改进请参考"改进OI平均值计算逻辑"日志条目。

### 影响范围
- ✅ 补全了提示词要求的所有数据
- ✅ AI现在可以进行完整的多周期分析（3m/15m/1h/4h）
- ✅ AI可以检查BTC的15m/1h/4h MACD方向
- ✅ AI可以使用买卖压力比进行多空确认
- ✅ AI可以检测成交量放量（>1.5x均量）
- ✅ AI可以判断OI变化（>+5%）（DeltaPercent字段已添加）
- ✅ AI可以进行完整的4小时RSI7分析
- ⚠️ 数据点数量仍为10个（后续修改增加到30个，见单独日志条目）

### 测试建议
1. 验证每个时间框架的数据是否完整（3m/15m/1h/4h）
2. 验证Volumes和BuySellRatios序列是否正确计算
3. 验证DeltaPercent字段是否正确添加到数据结构中
4. 验证BTC数据是否包含完整的多周期序列
5. 验证AI能否正确使用这些数据进行多周期分析

**注意**：OI平均值和变化百分比的计算逻辑改进请参考"改进OI平均值计算逻辑"日志条目。

---

