# 补丁日志 2025-11-13 (Patch Log 2025-11-13)

本文件记录2025年1月13日的所有自定义补丁和修复的详细信息。

---

## 2025-11-13 - 修复状态图标不更新和请求顺序问题

### 问题描述

#### 问题1：状态图标不更新
- **问题**: 添加、更新或删除模型/交易所配置后，状态图标（绿色/灰色圆点）不立即更新，需要刷新页面才能看到正确状态
- **场景**: 
  - 用户添加新模型配置后，状态图标应该立即显示为绿色（已启用）
  - 用户更新模型配置后，状态图标应该立即更新
  - 用户删除模型配置后，状态图标应该立即更新或消失
  - 但实际需要手动刷新页面才能看到正确状态
- **原因**: 
  - React 组件没有检测到状态变化，导致不重新渲染
  - 状态更新时没有创建新的对象引用
  - 列表项的 key 没有包含 `enabled` 状态，导致 React 无法识别变化
- **影响**: 
  - 用户体验差，无法实时看到配置状态
  - 需要手动刷新页面才能看到最新状态
  - 状态显示不准确，可能误导用户

#### 问题2：AlertDialog 可访问性警告
- **问题**: 删除模型或交易所时，控制台出现 `AlertDialogContent` 必须包含 `AlertDialogTitle` 的警告
- **原因**: 
  - Radix UI 的 `AlertDialog` 组件要求必须包含 `AlertDialogTitle` 以符合可访问性标准
  - 当没有提供标题时，组件没有渲染 `AlertDialogTitle`
- **影响**: 
  - 不符合 ARIA 可访问性要求
  - 控制台警告影响开发体验
  - 屏幕阅读器用户可能无法正确理解对话框内容

#### 问题3：请求顺序问题导致状态不正确
- **问题**: 保存配置后，立即 GET 请求返回的数据中 `enabled` 状态不正确（为 `false` 而不是 `true`）
- **场景**: 
  - 用户保存模型配置，设置 `enabled: true`
  - 保存成功后，立即调用 GET 请求获取最新数据
  - 返回的数据中 `enabled` 仍然是 `false`
  - 刷新页面后，`enabled` 才是 `true`
- **原因**: 
  - 使用 `toast.promise` 时，GET 请求可能在 PUT 请求完成之前执行
  - `toast.promise` 内部可能异步执行，导致请求顺序不确定
  - 后端虽然已经更新数据，但前端在更新完成前就获取了数据
- **影响**: 
  - 状态显示不正确
  - 用户体验差，需要刷新页面才能看到正确状态
  - 数据不一致

### 修复方案

#### 修复1：状态图标不更新问题

**方案**：
1. 添加 `updateKey` 状态用于强制重新渲染
2. 在所有状态更新操作后更新 `updateKey`
3. 在列表渲染时使用组合 key，包含 `updateKey` 和 `enabled` 状态
4. 确保状态更新时创建新的对象引用

**原理**：
- 使用组合 key 包含 `updateKey` 和 `enabled` 状态，当这些值变化时 React 会重新创建组件
- 每次更新后递增 `updateKey`，强制所有列表项重新渲染
- 创建新的对象引用确保 React 检测到变化

#### 修复2：AlertDialog 可访问性警告

**方案**：
- 确保 `AlertDialogTitle` 始终渲染
- 如果没有提供标题，使用默认标题 "确认" 并用 `sr-only` 类隐藏（仅对屏幕阅读器可见）

#### 修复3：请求顺序问题

**方案**：
- 将所有使用 `toast.promise` 的操作改为先执行 API 调用，再显示 toast
- 直接使用 `await` 确保 PUT 请求完成后再执行 GET 请求
- 移除不必要的 `setTimeout` 延迟

### 修改文件

#### `web/src/components/AITradersPage.tsx`

##### 1. 添加 `updateKey` 状态（第82行）

**修改前**:
```typescript
const [allModels, setAllModels] = useState<AIModel[]>([])
const [allExchanges, setAllExchanges] = useState<Exchange[]>([])
```

**修改后**:
```typescript
const [allModels, setAllModels] = useState<AIModel[]>([])
const [allExchanges, setAllExchanges] = useState<Exchange[]>([])
const [updateKey, setUpdateKey] = useState(0) // 用于强制重新渲染
```

##### 2. 修复 `handleSaveModelConfig` 函数（第473-572行）

**修改前**:
```typescript
await toast.promise(api.updateModelConfigs(request), {
  loading: '正在更新模型配置…',
  success: '模型配置已更新',
  error: '更新模型配置失败',
})

// 重新获取用户配置以确保数据同步
const refreshedModels = await api.getModelConfigs()
setAllModels(refreshedModels.map(m => ({ ...m })))
```

**修改后**:
```typescript
// 先执行更新操作，确保完成后再获取
await api.updateModelConfigs(request)
toast.success('模型配置已更新')

// 重新获取用户配置以确保数据同步
const refreshedModels = await api.getModelConfigs()

// 创建新的数组和对象引用，确保 React 检测到变化
setAllModels(refreshedModels.map(m => ({ ...m })))

// 强制触发重新渲染
setUpdateKey(prev => prev + 1)
```

##### 3. 修复 `handleSaveExchangeConfig` 函数（第626-722行）

**修改前**:
```typescript
await toast.promise(api.updateExchangeConfigsEncrypted(request), {
  loading: '正在更新交易所配置…',
  success: '交易所配置已更新',
  error: '更新交易所配置失败',
})

const refreshedExchanges = await api.getExchangeConfigs()
setAllExchanges(refreshedExchanges.map(e => ({ ...e })))
```

**修改后**:
```typescript
// 先执行更新操作，确保完成后再获取
await api.updateExchangeConfigsEncrypted(request)
toast.success('交易所配置已更新')

// 重新获取用户配置以确保数据同步
const refreshedExchanges = await api.getExchangeConfigs()
// 创建新的数组和对象引用，确保 React 检测到变化
setAllExchanges(refreshedExchanges.map(e => ({ ...e })))
// 强制触发重新渲染
setUpdateKey(prev => prev + 1)
```

##### 4. 修复 `handleDeleteConfig` 函数（第410-420行）

**修改前**:
```typescript
await toast.promise(config.updateApi(request), {
  loading: '正在更新配置…',
  success: '配置已更新',
  error: '更新配置失败',
})

const refreshedItems = await config.refreshApi()
config.setItems(refreshedItems)
```

**修改后**:
```typescript
// 先执行更新操作，确保完成后再获取
await config.updateApi(request)
toast.success('配置已更新')

// 重新获取用户配置以确保数据同步
const refreshedItems = await config.refreshApi()
config.setItems(refreshedItems)
```

##### 5. 修复模型列表渲染 key（第917行）

**修改前**:
```typescript
{configuredModels.map((model) => {
  return (
    <div key={model.id}>
```

**修改后**:
```typescript
{configuredModels.map((model) => {
  return (
    <div key={`${model.id}-${updateKey}-${model.enabled}`}>
```

##### 6. 修复交易所列表渲染 key（第996行）

**修改前**:
```typescript
{configuredExchanges.map((exchange) => {
  return (
    <div key={exchange.id}>
```

**修改后**:
```typescript
{configuredExchanges.map((exchange) => {
  return (
    <div key={`${exchange.id}-${updateKey}-${exchange.enabled}`}>
```

##### 7. 修复其他操作函数（第230-357行）

**修复的函数**：
- `handleCreateTrader` - 创建交易员
- `handleSaveEditTrader` - 更新交易员
- `handleDeleteTrader` - 删除交易员
- `handleToggleTrader` - 启动/停止交易员
- `handleSaveSignalSource` - 保存信号源配置

**修改模式**：
```typescript
// 修改前
await toast.promise(api.xxx(...), {
  loading: '...',
  success: '...',
  error: '...',
})

// 修改后
await api.xxx(...)
toast.success('...')
```

#### `web/src/components/ConfirmDialog.tsx`

##### 修复 AlertDialog 可访问性警告（第45-50行）

**修改前**:
```typescript
<AlertDialogContent>
  <div className="flex flex-col gap-5 text-center">
    {state.title && (
      <AlertDialogTitle className="text-xl">
        {state.title}
      </AlertDialogTitle>
    )}
    <AlertDialogDescription className="text-[var(--text-primary)] text-base font-medium">
      {state.message}
    </AlertDialogDescription>
  </div>
```

**修改后**:
```typescript
<AlertDialogContent>
  <div className="flex flex-col gap-5 text-center">
    <AlertDialogTitle className={state.title ? "text-xl" : "sr-only"}>
      {state.title || '确认'}
    </AlertDialogTitle>
    <AlertDialogDescription className="text-[var(--text-primary)] text-base font-medium">
      {state.message}
    </AlertDialogDescription>
  </div>
```

### 修复效果

#### 修复1效果
- ✅ 添加新模型配置后，状态图标立即显示为绿色
- ✅ 更新模型配置后，状态图标立即更新
- ✅ 删除模型配置后，状态图标立即更新或消失
- ✅ 交易所配置的状态图标同样能立即更新
- ✅ 不需要手动刷新页面即可看到最新状态

#### 修复2效果
- ✅ 删除操作不再出现可访问性警告
- ✅ 符合 ARIA 可访问性标准
- ✅ 屏幕阅读器用户可以正确理解对话框内容

#### 修复3效果
- ✅ 保存配置后，立即获取的数据中 `enabled` 状态正确
- ✅ 状态显示准确，不需要刷新页面
- ✅ 数据一致性得到保证
- ✅ 代码更简洁，移除了不必要的延迟

### 示例

**修复前**:
```
1. 用户添加模型配置
2. 保存成功，但状态图标仍然是灰色
3. 需要手动刷新页面才能看到绿色图标
4. 控制台出现可访问性警告
```

**修复后**:
```
1. 用户添加模型配置
2. 保存成功，状态图标立即显示为绿色
3. 不需要刷新页面
4. 无控制台警告
```

### 注意事项

- **React 重新渲染机制**：
  - 使用组合 key 强制重新渲染
  - 创建新的对象引用确保 React 检测到变化
  - 使用 `useMemo` 优化计算属性

- **异步请求顺序**：
  - 使用 `await` 确保请求顺序
  - 避免使用 `toast.promise` 导致的竞态条件
  - 保证数据一致性

- **数据库事务**：
  - SQLite WAL 模式 + `synchronous=FULL`
  - 确保数据持久化
  - 不需要额外的延迟等待（已移除 `setTimeout`）

### 测试建议

1. **状态图标更新测试**：
   - 添加新模型配置，验证状态图标是否立即显示为绿色
   - 更新模型配置，验证状态图标是否立即更新
   - 删除模型配置，验证状态图标是否立即更新或消失
   - 对交易所配置执行相同测试

2. **可访问性测试**：
   - 删除模型或交易所，验证控制台是否无警告
   - 使用屏幕阅读器测试对话框可访问性

3. **数据一致性测试**：
   - 保存配置后，立即检查状态是否正确
   - 验证不需要刷新页面即可看到最新状态
   - 验证多个操作连续执行时数据是否正确

4. **性能测试**：
   - 验证移除 `setTimeout` 后响应速度是否提升
   - 验证大量操作时是否有性能问题

---

## 2025-11-13 - 修复错误提示信息显示和添加数据验证

### 问题描述

#### 问题1：创建交易员时出现重复提示
- **问题**: 创建交易员失败时，同时显示"创建交易员失败"和"保存成功"两个提示信息
- **场景**: 
  - 用户创建交易员时，如果后端返回错误（如"山寨币杠杆必须在1-20倍之间"）
  - 前端同时显示两个提示：通用的"创建交易员失败"和"保存成功"
  - 用户无法看到具体的错误信息
- **原因**: 
  - `TraderConfigModal` 使用 `toast.promise` 显示提示
  - `handleCreateTrader` 函数内部也有自己的 toast 消息
  - 导致错误时显示两个提示，成功时也显示两个提示
- **影响**: 
  - 用户体验差，无法看到具体的错误信息
  - 提示信息混乱，误导用户

#### 问题2：启动/停止交易员时错误信息不详细
- **问题**: 启动或停止交易员失败时，只显示"操作失败"，不显示具体的错误信息
- **场景**: 
  - 用户启动交易员时，如果交易员不存在（404错误）
  - 后端返回 `{"error":"交易员不存在"}`
  - 前端只显示"操作失败"，不显示"交易员不存在"
- **原因**: 
  - `api.startTrader` 和 `api.stopTrader` 没有提取服务器返回的具体错误信息
  - `handleToggleTrader` 只显示通用的错误消息
- **影响**: 
  - 用户无法知道具体的失败原因
  - 调试困难

#### 问题3：编辑交易所时错误信息不详细
- **问题**: 编辑交易所失败时，只显示"保存配置失败"，不显示具体的错误信息
- **场景**: 
  - 用户编辑 Aster 交易所时，如果私钥格式错误
  - 后端返回具体的错误信息（如"Aster 私钥格式错误: 包含无效字符 's'"）
  - 前端只显示"保存配置失败"
- **原因**: 
  - `api.updateExchangeConfigsEncrypted` 没有提取服务器返回的具体错误信息
  - `handleSaveExchangeConfig` 只显示通用的错误消息
- **影响**: 
  - 用户无法知道具体的失败原因
  - 无法快速定位问题

#### 问题4：Aster 私钥格式验证缺失
- **问题**: 在配置交易所时，没有验证 Aster 私钥格式，导致创建交易员时失败
- **场景**: 
  - 用户配置 Aster 交易所时，输入了格式错误的私钥
  - 保存成功，但在创建交易员时失败
  - 错误信息："解析私钥失败: invalid hex character 's' in private key"
- **原因**: 
  - 前端没有验证私钥格式
  - 后端在创建交易员时才验证，此时已经保存到数据库
- **影响**: 
  - 用户需要等到创建交易员时才发现问题
  - 数据已经保存，需要重新编辑

#### 问题5：初始金额验证缺失
- **问题**: 创建交易员时，如果初始金额为0，会在加载到内存时才报错
- **场景**: 
  - 用户创建交易员时，交易所余额为0或查询失败
  - 交易员创建成功，但在加载到内存时失败
  - 错误信息："初始金额必须大于0，请在配置中设置InitialBalance"
- **原因**: 
  - 创建交易员时没有验证初始金额
  - 验证在 `LoadTraderByID` 时进行，此时交易员已经保存到数据库
- **影响**: 
  - 交易员创建成功但无法使用
  - 需要手动删除后重新创建

### 修复方案

#### 修复1：统一错误提示处理
- **文件**: `web/src/components/AITradersPage.tsx`
- **修改**:
  - 移除 `handleCreateTrader` 和 `handleSaveEditTrader` 内部的 toast 消息
  - 将验证错误改为抛出 Error，由 `toast.promise` 统一处理
  - 确保错误信息正确传递

#### 修复2：提取服务器错误信息
- **文件**: `web/src/lib/api.ts`
- **修改**:
  - `api.createTrader`: 提取服务器返回的具体错误信息
  - `api.updateTrader`: 提取服务器返回的具体错误信息
  - `api.startTrader`: 提取服务器返回的具体错误信息
  - `api.stopTrader`: 提取服务器返回的具体错误信息
  - `api.updateExchangeConfigsEncrypted`: 提取服务器返回的具体错误信息

#### 修复3：显示详细错误信息
- **文件**: `web/src/components/AITradersPage.tsx`
- **修改**:
  - `handleToggleTrader`: 显示具体的错误信息
  - `handleSaveExchangeConfig`: 显示具体的错误信息

#### 修复4：添加 Aster 私钥格式验证
- **文件**: `api/server.go`
- **修改**:
  - 添加 `validateAsterPrivateKey` 函数，验证私钥格式
  - 在 `handleUpdateExchangeConfigs` 中，更新 Aster 交易所配置前验证私钥格式
  - 验证长度（64个十六进制字符）和字符有效性

#### 修复5：添加初始金额验证
- **文件**: `api/server.go`
- **修改**:
  - 在 `handleCreateTrader` 中，创建交易员前验证初始金额必须大于0
  - 在 `handleUpdateTrader` 中，更新交易员前验证初始金额必须大于0
  - 确保交易员创建时就有有效的初始金额

#### 修复6：改进 TraderConfigModal 提示信息
- **文件**: `web/src/components/TraderConfigModal.tsx`
- **修改**:
  - 根据 `isEditMode` 显示不同的成功消息（"创建成功" vs "保存成功"）
  - 根据 `isEditMode` 显示不同的默认错误消息
  - 确保错误信息正确显示

### 修改的文件

1. **web/src/lib/api.ts**
   - 修改 `createTrader`: 提取服务器错误信息
   - 修改 `updateTrader`: 提取服务器错误信息
   - 修改 `startTrader`: 提取服务器错误信息
   - 修改 `stopTrader`: 提取服务器错误信息
   - 修改 `updateExchangeConfigsEncrypted`: 提取服务器错误信息

2. **web/src/components/AITradersPage.tsx**
   - 修改 `handleCreateTrader`: 移除内部 toast，统一由 `toast.promise` 处理
   - 修改 `handleSaveEditTrader`: 移除内部 toast，统一由 `toast.promise` 处理
   - 修改 `handleToggleTrader`: 显示具体错误信息
   - 修改 `handleSaveExchangeConfig`: 显示具体错误信息

3. **web/src/components/TraderConfigModal.tsx**
   - 修改 `handleSave`: 根据 `isEditMode` 显示不同的成功/错误消息
   - 修复类型错误

4. **api/server.go**
   - 添加 `validateAsterPrivateKey` 函数
   - 修改 `handleUpdateExchangeConfigs`: 添加 Aster 私钥格式验证
   - 修改 `handleCreateTrader`: 添加初始金额验证
   - 修改 `handleUpdateTrader`: 添加初始金额验证和移除旧 trader 实例

### 修复效果

**修复前**:
```
1. 创建交易员失败时，显示"创建交易员失败"和"保存成功"两个提示
2. 启动交易员失败时，只显示"操作失败"
3. 编辑交易所失败时，只显示"保存配置失败"
4. Aster 私钥格式错误时，在创建交易员时才报错
5. 初始金额为0时，在加载到内存时才报错
```

**修复后**:
```
1. 创建交易员失败时，只显示一个包含具体错误信息的提示（如"山寨币杠杆必须在1-20倍之间"）
2. 启动交易员失败时，显示具体错误信息（如"交易员不存在"）
3. 编辑交易所失败时，显示具体错误信息（如"Aster 私钥格式错误: 包含无效字符 's'"）
4. Aster 私钥格式错误时，在配置交易所时就报错
5. 初始金额为0时，在创建交易员时就报错
```

### 注意事项

- **错误信息提取**：
  - 所有 API 函数都统一提取服务器返回的 `error` 字段
  - 如果提取失败，使用默认错误消息
  - 确保错误信息正确传递到前端

- **Toast 提示统一管理**：
  - 使用 `toast.promise` 统一管理成功/失败提示
  - 避免在多个地方显示重复的提示
  - 根据操作类型显示不同的消息

- **数据验证时机**：
  - 在数据保存到数据库前进行验证
  - 避免保存无效数据后再报错
  - 提供清晰的错误提示

### 测试建议

1. **错误提示测试**：
   - 创建交易员时输入无效杠杆值，验证是否显示具体错误信息
   - 启动不存在的交易员，验证是否显示"交易员不存在"
   - 编辑交易所时输入无效私钥，验证是否显示具体错误信息

2. **数据验证测试**：
   - 配置 Aster 交易所时输入格式错误的私钥，验证是否在保存时就报错
   - 创建交易员时初始金额为0，验证是否在创建时就报错

3. **提示信息测试**：
   - 创建交易员成功时，验证是否只显示一次"创建成功"
   - 编辑交易员成功时，验证是否只显示一次"保存成功"
   - 操作失败时，验证是否只显示一次包含具体错误信息的提示

---

## 2025-11-13 - 修复交易员窗口获取余额API请求地址错误

### 问题描述

- **问题**: 在交易员的窗口，点击获取余额时出现 404 错误
- **错误信息**: 请求地址错误，实际请求的地址是 `https://jan.9link.top/api/account?`
- **场景**: 
  - 用户在编辑交易员配置时，点击"获取余额"按钮
  - 前端发送请求到错误的API端点
  - 后端返回 404 错误
- **原因**: 
  1. **API端点错误**: 前端使用了 `/api/account?trader_id=xxx` 端点，但该端点可能不存在或需要交易员正在运行
  2. **API前缀缺失**: 前端代码中直接使用了 `/api/` 前缀，但实际应该使用 `/nofx-api/` 前缀
  3. **端点选择不当**: 应该使用专门的同步余额端点 `/api/traders/:id/sync-balance`，而不是账户信息端点
- **影响**: 
  - 用户无法获取当前余额
  - 需要手动输入初始余额
  - 用户体验差

### 修复方案

#### 1. 修改API端点
- **修改前**: 使用 `/api/account?trader_id=${traderData.trader_id}` (GET请求)
- **修改后**: 使用 `/nofx-api/traders/${traderData.trader_id}/sync-balance` (POST请求)

#### 2. 修改HTTP方法
- **修改前**: GET 请求
- **修改后**: POST 请求（符合后端路由要求）

#### 3. 修改响应数据解析
- **修改前**: 解析 `data.total_equity` 或 `data.balance`
- **修改后**: 解析 `data.new_balance`（sync-balance 端点返回的字段）

#### 4. 改进错误处理
- 添加更详细的错误信息提取
- 显示服务器返回的具体错误消息
- 改进成功提示，显示获取到的余额数值

### 修改文件

- **文件**: `web/src/components/TraderConfigModal.tsx`
- **函数**: `handleFetchCurrentBalance`
- **行数**: 220-265

### 代码变更

**修改前**:
```typescript
const response = await fetch(
  `/api/account?trader_id=${traderData.trader_id}`,
  {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  }
)

const data = await response.json()
const currentBalance = data.total_equity || data.balance || 0
toast.success('已获取当前余额')
```

**修改后**:
```typescript
const response = await fetch(
  `/nofx-api/traders/${traderData.trader_id}/sync-balance`,
  {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
    },
  }
)

if (!response.ok) {
  const errorData = await response.json().catch(() => ({}))
  throw new Error(errorData.error || '获取账户余额失败')
}

const data = await response.json()
const currentBalance = data.new_balance || data.balance || 0
setFormData((prev) => ({ ...prev, initial_balance: currentBalance }))
toast.success(`已获取当前余额: ${currentBalance.toFixed(2)} USDT`)
```

### 后端端点说明

- **端点**: `POST /api/traders/:id/sync-balance`
- **功能**: 从交易所获取实际余额并同步到数据库
- **返回数据**:
  ```json
  {
    "message": "余额同步成功",
    "old_balance": 1000.0,
    "new_balance": 1500.0,
    "change_percent": 50.0,
    "change_type": "增加"
  }
  ```

### 修复效果

**修复前**:
- 点击获取余额时返回 404 错误
- 无法获取当前余额
- 需要手动输入初始余额

**修复后**:
- 点击获取余额时成功调用正确的API端点
- 从交易所获取实际余额并更新到表单
- 显示获取到的余额数值
- 自动更新数据库中的 `initial_balance` 字段

### 注意事项

- **API前缀**: 所有前端API请求都应该使用 `/nofx-api/` 前缀，该前缀会通过 Vite 代理转发到后端的 `/api/` 路径
- **端点选择**: 
  - `/api/account` 端点需要交易员正在运行才能获取账户信息
  - `/api/traders/:id/sync-balance` 端点可以直接从交易所获取余额，更适合在配置时使用
- **数据同步**: `sync-balance` 端点不仅返回余额，还会自动更新数据库中的 `initial_balance` 字段

### 测试建议

1. **功能测试**:
   - 在编辑交易员配置时，点击"获取余额"按钮
   - 验证是否成功获取余额并更新到表单
   - 验证是否显示正确的余额数值

2. **错误处理测试**:
   - 测试未登录时的错误处理
   - 测试交易员不存在时的错误处理
   - 测试交易所未配置时的错误处理

3. **API路径测试**:
   - 验证请求是否发送到正确的 `/nofx-api/traders/:id/sync-balance` 端点
   - 验证请求方法是否为 POST
   - 验证响应数据是否正确解析

---

## 2025-11-14 - 修复创建交易员时无法从币安API提取余额的问题

### 问题描述

- **问题**: 在新建交易员时，前端提示创建成功，但后端出现警告，无法从余额信息中提取可用余额
- **错误信息**: 
  ```
  ✓ 币安API返回: 总余额=338.19170165, 可用=338.19170165, 未实现盈亏=0.00000000
  ⚠️ 无法从余额信息中提取可用余额，使用用户输入的初始资金
  ⚠️ 加载交易员到内存失败: 创建trader失败: 初始金额必须大于0，请在配置中设置InitialBalance
  ```
- **场景**: 
  - 用户创建新交易员时，系统尝试从交易所获取实际余额
  - 币安API成功返回了余额信息
  - 但代码无法从返回的数据中提取余额值
  - 导致使用用户输入的初始资金（可能为0），最终加载到内存时失败
- **原因**: 
  1. **字段名不匹配**: 币安返回的字段是 `availableBalance`（驼峰命名），但代码只检查 `available_balance`（下划线命名）
  2. **缺少备选字段**: 代码没有检查 `totalWalletBalance` 字段作为备选
  3. **缺少验证**: 创建交易员前没有验证初始余额必须大于0，导致创建成功但加载失败
- **影响**: 
  - 无法自动获取交易所余额
  - 需要手动输入初始余额
  - 如果用户输入的余额为0，会导致创建成功但无法加载到内存

### 修复方案

#### 1. 修复余额提取逻辑
- **问题**: 代码检查的字段名与币安返回的字段名不匹配
- **修复**: 检查统一的字段格式（所有交易所都已统一使用驼峰命名）
  - 优先使用 `availableBalance`
  - 备选使用 `totalWalletBalance`（当可用余额为0时）

#### 2. 简化代码逻辑
- **发现**: 所有交易所（币安、Hyperliquid、Aster）都已统一使用驼峰命名格式
- **优化**: 移除了对 `available_balance` 和 `balance` 字段的检查，简化代码

#### 3. 添加初始余额验证
- **问题**: 如果无法提取余额且用户输入的余额为0，会在加载到内存时失败
- **修复**: 在创建交易员之前验证初始余额必须大于0，提前返回错误

#### 4. 添加调试辅助函数
- 添加 `getMapKeys` 函数用于调试，当无法提取余额时显示所有可用字段

### 修改文件

- **文件**: `api/server.go`
- **函数**: 
  - `handleCreateTrader` (创建交易员)
  - `handleSyncBalance` (同步余额)
- **新增函数**: `getMapKeys` (调试辅助函数)

### 代码变更

#### 1. 余额提取逻辑（创建交易员）

**修改前**:
```go
// 提取可用余额
if availableBalance, ok := balanceInfo["available_balance"].(float64); ok && availableBalance > 0 {
    actualBalance = availableBalance
    log.Printf("✓ 查询到交易所实际余额: %.2f USDT (用户输入: %.2f USDT)", actualBalance, req.InitialBalance)
} else if totalBalance, ok := balanceInfo["balance"].(float64); ok && totalBalance > 0 {
    actualBalance = totalBalance
    log.Printf("✓ 查询到交易所实际余额: %.2f USDT (用户输入: %.2f USDT)", actualBalance, req.InitialBalance)
} else {
    log.Printf("⚠️ 无法从余额信息中提取可用余额，使用用户输入的初始资金")
}
```

**修改后**:
```go
// 提取可用余额（所有交易所统一使用驼峰命名格式）
// 统一字段: availableBalance, totalWalletBalance, totalUnrealizedProfit
var extractedBalance float64
var found bool

// 优先使用可用余额
if availableBalance, ok := balanceInfo["availableBalance"].(float64); ok && availableBalance > 0 {
    extractedBalance = availableBalance
    found = true
    log.Printf("✓ 从 availableBalance 字段提取余额: %.2f USDT", extractedBalance)
} else if totalBalance, ok := balanceInfo["totalWalletBalance"].(float64); ok && totalBalance > 0 {
    // 如果可用余额为0，使用总余额作为备选
    extractedBalance = totalBalance
    found = true
    log.Printf("✓ 从 totalWalletBalance 字段提取余额: %.2f USDT", extractedBalance)
}

if found {
    actualBalance = extractedBalance
    log.Printf("✓ 查询到交易所实际余额: %.2f USDT (用户输入: %.2f USDT)", actualBalance, req.InitialBalance)
} else {
    // 调试：打印所有可用的字段
    log.Printf("⚠️ 无法从余额信息中提取可用余额")
    log.Printf("   余额信息包含的字段: %v", getMapKeys(balanceInfo))
    log.Printf("   使用用户输入的初始资金: %.2f USDT", req.InitialBalance)
}
```

#### 2. 添加初始余额验证

**新增代码**:
```go
// 验证初始金额必须大于0
if actualBalance <= 0 {
    c.JSON(http.StatusBadRequest, gin.H{
        "error": "初始金额必须大于0，请检查交易所余额或手动设置初始金额。如果已配置交易所，请确保API密钥正确且账户有余额。",
    })
    return
}
```

#### 3. 同步余额逻辑（简化）

**修改前**:
```go
// 提取可用余额
var actualBalance float64
if availableBalance, ok := balanceInfo["available_balance"].(float64); ok && availableBalance > 0 {
    actualBalance = availableBalance
} else if availableBalance, ok := balanceInfo["availableBalance"].(float64); ok && availableBalance > 0 {
    actualBalance = availableBalance
} else if totalBalance, ok := balanceInfo["balance"].(float64); ok && totalBalance > 0 {
    actualBalance = totalBalance
} else {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "无法获取可用余额"})
    return
}
```

**修改后**:
```go
// 提取可用余额（所有交易所统一使用驼峰命名格式）
var actualBalance float64
if availableBalance, ok := balanceInfo["availableBalance"].(float64); ok && availableBalance > 0 {
    actualBalance = availableBalance
} else if totalBalance, ok := balanceInfo["totalWalletBalance"].(float64); ok && totalBalance > 0 {
    // 如果可用余额为0，使用总余额作为备选
    actualBalance = totalBalance
} else {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "无法获取可用余额"})
    return
}
```

#### 4. 新增调试辅助函数

```go
// getMapKeys 获取 map 的所有键（用于调试）
func getMapKeys(m map[string]interface{}) []string {
    keys := make([]string, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}
```

### 统一字段格式说明

所有交易所（币安、Hyperliquid、Aster）都统一返回以下字段：
- `availableBalance` - 可用余额（float64）
- `totalWalletBalance` - 总钱包余额（float64）
- `totalUnrealizedProfit` - 未实现盈亏（float64）

### 修复效果

**修复前**:
- 币安API返回余额但无法提取
- 使用用户输入的初始资金（可能为0）
- 创建成功但加载到内存失败
- 需要手动输入初始余额

**修复后**:
- 正确识别币安返回的 `availableBalance` 字段
- 成功提取余额并设置初始金额
- 如果无法提取余额且用户输入为0，在创建前就返回错误
- 自动从交易所获取余额，无需手动输入

### 注意事项

- **字段格式统一**: 所有交易所都已统一使用驼峰命名格式，不再需要检查下划线命名
- **备选方案**: 如果 `availableBalance` 为0，会使用 `totalWalletBalance` 作为备选
- **提前验证**: 在创建交易员之前就验证初始余额，避免创建成功但加载失败的情况
- **调试支持**: 如果无法提取余额，会打印所有可用字段，便于调试

### 测试建议

1. **币安交易所测试**:
   - 创建币安交易员，验证是否能正确提取余额
   - 验证日志中显示 "从 availableBalance 字段提取余额"

2. **其他交易所测试**:
   - 创建 Hyperliquid 交易员，验证余额提取
   - 创建 Aster 交易员，验证余额提取

3. **错误处理测试**:
   - 测试无法获取余额时的错误提示
   - 测试初始余额为0时的验证错误

4. **同步余额测试**:
   - 测试同步余额功能是否正常工作
   - 验证同步余额时也能正确提取余额

---

